// Code generated by protoc-gen-go. DO NOT EDIT.
// source: spec.proto

package gauge_messages

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// / Execution Status
type ExecutionStatus int32

const (
	ExecutionStatus_NOTEXECUTED ExecutionStatus = 0
	ExecutionStatus_PASSED      ExecutionStatus = 1
	ExecutionStatus_FAILED      ExecutionStatus = 2
	ExecutionStatus_SKIPPED     ExecutionStatus = 3
)

var ExecutionStatus_name = map[int32]string{
	0: "NOTEXECUTED",
	1: "PASSED",
	2: "FAILED",
	3: "SKIPPED",
}
var ExecutionStatus_value = map[string]int32{
	"NOTEXECUTED": 0,
	"PASSED":      1,
	"FAILED":      2,
	"SKIPPED":     3,
}

func (x ExecutionStatus) String() string {
	return proto.EnumName(ExecutionStatus_name, int32(x))
}
func (ExecutionStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

// / Enumerates various item types that the proto item can contain. Valid types are: Step, Comment, Concept, Scenario, TableDrivenScenario, Table, Tags
type ProtoItem_ItemType int32

const (
	ProtoItem_Step                ProtoItem_ItemType = 0
	ProtoItem_Comment             ProtoItem_ItemType = 1
	ProtoItem_Concept             ProtoItem_ItemType = 2
	ProtoItem_Scenario            ProtoItem_ItemType = 3
	ProtoItem_TableDrivenScenario ProtoItem_ItemType = 4
	ProtoItem_Table               ProtoItem_ItemType = 5
	ProtoItem_Tags                ProtoItem_ItemType = 6
)

var ProtoItem_ItemType_name = map[int32]string{
	0: "Step",
	1: "Comment",
	2: "Concept",
	3: "Scenario",
	4: "TableDrivenScenario",
	5: "Table",
	6: "Tags",
}
var ProtoItem_ItemType_value = map[string]int32{
	"Step":                0,
	"Comment":             1,
	"Concept":             2,
	"Scenario":            3,
	"TableDrivenScenario": 4,
	"Table":               5,
	"Tags":                6,
}

func (x ProtoItem_ItemType) String() string {
	return proto.EnumName(ProtoItem_ItemType_name, int32(x))
}
func (ProtoItem_ItemType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{1, 0} }

// / Enum representing the types of Fragment
type Fragment_FragmentType int32

const (
	Fragment_Text      Fragment_FragmentType = 0
	Fragment_Parameter Fragment_FragmentType = 1
)

var Fragment_FragmentType_name = map[int32]string{
	0: "Text",
	1: "Parameter",
}
var Fragment_FragmentType_value = map[string]int32{
	"Text":      0,
	"Parameter": 1,
}

func (x Fragment_FragmentType) String() string {
	return proto.EnumName(Fragment_FragmentType_name, int32(x))
}
func (Fragment_FragmentType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{8, 0} }

// / Enum representing types of Parameter.
type Parameter_ParameterType int32

const (
	Parameter_Static         Parameter_ParameterType = 0
	Parameter_Dynamic        Parameter_ParameterType = 1
	Parameter_Special_String Parameter_ParameterType = 2
	Parameter_Special_Table  Parameter_ParameterType = 3
	Parameter_Table          Parameter_ParameterType = 4
)

var Parameter_ParameterType_name = map[int32]string{
	0: "Static",
	1: "Dynamic",
	2: "Special_String",
	3: "Special_Table",
	4: "Table",
}
var Parameter_ParameterType_value = map[string]int32{
	"Static":         0,
	"Dynamic":        1,
	"Special_String": 2,
	"Special_Table":  3,
	"Table":          4,
}

func (x Parameter_ParameterType) String() string {
	return proto.EnumName(Parameter_ParameterType_name, int32(x))
}
func (Parameter_ParameterType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{9, 0} }

type ProtoExecutionResult_ErrorType int32

const (
	ProtoExecutionResult_ASSERTION    ProtoExecutionResult_ErrorType = 0
	ProtoExecutionResult_VERIFICATION ProtoExecutionResult_ErrorType = 1
)

var ProtoExecutionResult_ErrorType_name = map[int32]string{
	0: "ASSERTION",
	1: "VERIFICATION",
}
var ProtoExecutionResult_ErrorType_value = map[string]int32{
	"ASSERTION":    0,
	"VERIFICATION": 1,
}

func (x ProtoExecutionResult_ErrorType) String() string {
	return proto.EnumName(ProtoExecutionResult_ErrorType_name, int32(x))
}
func (ProtoExecutionResult_ErrorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{14, 0}
}

type Error_ErrorType int32

const (
	Error_PARSE_ERROR      Error_ErrorType = 0
	Error_VALIDATION_ERROR Error_ErrorType = 1
)

var Error_ErrorType_name = map[int32]string{
	0: "PARSE_ERROR",
	1: "VALIDATION_ERROR",
}
var Error_ErrorType_value = map[string]int32{
	"PARSE_ERROR":      0,
	"VALIDATION_ERROR": 1,
}

func (x Error_ErrorType) String() string {
	return proto.EnumName(Error_ErrorType_name, int32(x))
}
func (Error_ErrorType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{18, 0} }

// / A proto object representing a Specification
// / A specification can contain Scenarios or Steps, besides Comments
type ProtoSpec struct {
	// / Heading describing the Specification
	SpecHeading string `protobuf:"bytes,1,opt,name=specHeading" json:"specHeading,omitempty"`
	// / A collection of items that come under this step
	Items []*ProtoItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	// / Flag indicating if this is a Table Driven Specification. The table is defined in the context, this is different from using a table parameter.
	IsTableDriven bool `protobuf:"varint,3,opt,name=isTableDriven" json:"isTableDriven,omitempty"`
	// / Contains a 'before' hook failure message. This happens when the `before_spec` hook has an error.
	PreHookFailures []*ProtoHookFailure `protobuf:"bytes,4,rep,name=preHookFailures" json:"preHookFailures,omitempty"`
	// / Contains a 'before' hook failure message. This happens when the `after_hook` hook has an error.
	PostHookFailures []*ProtoHookFailure `protobuf:"bytes,5,rep,name=postHookFailures" json:"postHookFailures,omitempty"`
	// / Contains the filename for that holds this specification.
	FileName string `protobuf:"bytes,6,opt,name=fileName" json:"fileName,omitempty"`
	// / Contains a list of tags that are defined at the specification level. Scenario tags are not present here.
	Tags []string `protobuf:"bytes,7,rep,name=tags" json:"tags,omitempty"`
	// / Additional information at pre hook exec time to be available on reports
	PreHookMessages []string `protobuf:"bytes,8,rep,name=preHookMessages" json:"preHookMessages,omitempty"`
	// / Additional information at post hook exec time to be available on reports
	PostHookMessages []string `protobuf:"bytes,9,rep,name=postHookMessages" json:"postHookMessages,omitempty"`
}

func (m *ProtoSpec) Reset()                    { *m = ProtoSpec{} }
func (m *ProtoSpec) String() string            { return proto.CompactTextString(m) }
func (*ProtoSpec) ProtoMessage()               {}
func (*ProtoSpec) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *ProtoSpec) GetSpecHeading() string {
	if m != nil {
		return m.SpecHeading
	}
	return ""
}

func (m *ProtoSpec) GetItems() []*ProtoItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *ProtoSpec) GetIsTableDriven() bool {
	if m != nil {
		return m.IsTableDriven
	}
	return false
}

func (m *ProtoSpec) GetPreHookFailures() []*ProtoHookFailure {
	if m != nil {
		return m.PreHookFailures
	}
	return nil
}

func (m *ProtoSpec) GetPostHookFailures() []*ProtoHookFailure {
	if m != nil {
		return m.PostHookFailures
	}
	return nil
}

func (m *ProtoSpec) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ProtoSpec) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *ProtoSpec) GetPreHookMessages() []string {
	if m != nil {
		return m.PreHookMessages
	}
	return nil
}

func (m *ProtoSpec) GetPostHookMessages() []string {
	if m != nil {
		return m.PostHookMessages
	}
	return nil
}

// / Container for all valid Items under a Specification.
type ProtoItem struct {
	// / Itemtype of the current ProtoItem
	ItemType ProtoItem_ItemType `protobuf:"varint,1,opt,name=itemType,enum=gauge.messages.ProtoItem_ItemType" json:"itemType,omitempty"`
	// / Holds the Step definition. Valid only if ItemType = Step
	Step *ProtoStep `protobuf:"bytes,2,opt,name=step" json:"step,omitempty"`
	// / Holds the Concept definition. Valid only if ItemType = Concept
	Concept *ProtoConcept `protobuf:"bytes,3,opt,name=concept" json:"concept,omitempty"`
	// / Holds the Scenario definition. Valid only if ItemType = Scenario
	Scenario *ProtoScenario `protobuf:"bytes,4,opt,name=scenario" json:"scenario,omitempty"`
	// / Holds the TableDrivenScenario definition. Valid only if ItemType = TableDrivenScenario
	TableDrivenScenario *ProtoTableDrivenScenario `protobuf:"bytes,5,opt,name=tableDrivenScenario" json:"tableDrivenScenario,omitempty"`
	// / Holds the Comment definition. Valid only if ItemType = Comment
	Comment *ProtoComment `protobuf:"bytes,6,opt,name=comment" json:"comment,omitempty"`
	// / Holds the Table definition. Valid only if ItemType = Table
	Table *ProtoTable `protobuf:"bytes,7,opt,name=table" json:"table,omitempty"`
	// / Holds the Tags definition. Valid only if ItemType = Tags
	Tags *ProtoTags `protobuf:"bytes,8,opt,name=tags" json:"tags,omitempty"`
}

func (m *ProtoItem) Reset()                    { *m = ProtoItem{} }
func (m *ProtoItem) String() string            { return proto.CompactTextString(m) }
func (*ProtoItem) ProtoMessage()               {}
func (*ProtoItem) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *ProtoItem) GetItemType() ProtoItem_ItemType {
	if m != nil {
		return m.ItemType
	}
	return ProtoItem_Step
}

func (m *ProtoItem) GetStep() *ProtoStep {
	if m != nil {
		return m.Step
	}
	return nil
}

func (m *ProtoItem) GetConcept() *ProtoConcept {
	if m != nil {
		return m.Concept
	}
	return nil
}

func (m *ProtoItem) GetScenario() *ProtoScenario {
	if m != nil {
		return m.Scenario
	}
	return nil
}

func (m *ProtoItem) GetTableDrivenScenario() *ProtoTableDrivenScenario {
	if m != nil {
		return m.TableDrivenScenario
	}
	return nil
}

func (m *ProtoItem) GetComment() *ProtoComment {
	if m != nil {
		return m.Comment
	}
	return nil
}

func (m *ProtoItem) GetTable() *ProtoTable {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *ProtoItem) GetTags() *ProtoTags {
	if m != nil {
		return m.Tags
	}
	return nil
}

// / A proto object representing a Scenario
type ProtoScenario struct {
	// / Heading of the given Scenario
	ScenarioHeading string `protobuf:"bytes,1,opt,name=scenarioHeading" json:"scenarioHeading,omitempty"`
	// / Flag to indicate if the Scenario execution failed
	Failed bool `protobuf:"varint,2,opt,name=failed" json:"failed,omitempty"`
	// / Collection of Context steps. The Context steps are executed before every run.
	Contexts []*ProtoItem `protobuf:"bytes,3,rep,name=contexts" json:"contexts,omitempty"`
	// / Collection of Items under a scenario. These could be Steps, Comments, Tags, TableDrivenScenarios or Tables
	ScenarioItems []*ProtoItem `protobuf:"bytes,4,rep,name=scenarioItems" json:"scenarioItems,omitempty"`
	// / Contains a 'before' hook failure message. This happens when the `before_scenario` hook has an error.
	PreHookFailure *ProtoHookFailure `protobuf:"bytes,5,opt,name=preHookFailure" json:"preHookFailure,omitempty"`
	// / Contains a 'after' hook failure message. This happens when the `after_scenario` hook has an error.
	PostHookFailure *ProtoHookFailure `protobuf:"bytes,6,opt,name=postHookFailure" json:"postHookFailure,omitempty"`
	// / Contains a list of tags that are defined at the specification level. Scenario tags are not present here.
	Tags []string `protobuf:"bytes,7,rep,name=tags" json:"tags,omitempty"`
	// / Holds the time taken for executing this scenario.
	ExecutionTime int64 `protobuf:"varint,8,opt,name=executionTime" json:"executionTime,omitempty"`
	// / Flag to indicate if the Scenario execution is skipped
	Skipped bool `protobuf:"varint,9,opt,name=skipped" json:"skipped,omitempty"`
	// / Holds the error messages for skipping scenario from execution
	SkipErrors []string `protobuf:"bytes,10,rep,name=skipErrors" json:"skipErrors,omitempty"`
	// / Holds the unique Identifier of a scenario.
	ID string `protobuf:"bytes,11,opt,name=ID" json:"ID,omitempty"`
	// / Collection of Teardown steps. The Teardown steps are executed after every run.
	TearDownSteps []*ProtoItem `protobuf:"bytes,12,rep,name=tearDownSteps" json:"tearDownSteps,omitempty"`
	// / Span(start, end) of scenario
	Span *Span `protobuf:"bytes,13,opt,name=span" json:"span,omitempty"`
	// / Execution status for the scenario
	ExecutionStatus ExecutionStatus `protobuf:"varint,14,opt,name=executionStatus,enum=gauge.messages.ExecutionStatus" json:"executionStatus,omitempty"`
	// / Additional information at pre hook exec time to be available on reports
	PreHookMessages []string `protobuf:"bytes,15,rep,name=preHookMessages" json:"preHookMessages,omitempty"`
	// / Additional information at post hook exec time to be available on reports
	PostHookMessages []string `protobuf:"bytes,16,rep,name=postHookMessages" json:"postHookMessages,omitempty"`
}

func (m *ProtoScenario) Reset()                    { *m = ProtoScenario{} }
func (m *ProtoScenario) String() string            { return proto.CompactTextString(m) }
func (*ProtoScenario) ProtoMessage()               {}
func (*ProtoScenario) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *ProtoScenario) GetScenarioHeading() string {
	if m != nil {
		return m.ScenarioHeading
	}
	return ""
}

func (m *ProtoScenario) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *ProtoScenario) GetContexts() []*ProtoItem {
	if m != nil {
		return m.Contexts
	}
	return nil
}

func (m *ProtoScenario) GetScenarioItems() []*ProtoItem {
	if m != nil {
		return m.ScenarioItems
	}
	return nil
}

func (m *ProtoScenario) GetPreHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PreHookFailure
	}
	return nil
}

func (m *ProtoScenario) GetPostHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PostHookFailure
	}
	return nil
}

func (m *ProtoScenario) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *ProtoScenario) GetExecutionTime() int64 {
	if m != nil {
		return m.ExecutionTime
	}
	return 0
}

func (m *ProtoScenario) GetSkipped() bool {
	if m != nil {
		return m.Skipped
	}
	return false
}

func (m *ProtoScenario) GetSkipErrors() []string {
	if m != nil {
		return m.SkipErrors
	}
	return nil
}

func (m *ProtoScenario) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ProtoScenario) GetTearDownSteps() []*ProtoItem {
	if m != nil {
		return m.TearDownSteps
	}
	return nil
}

func (m *ProtoScenario) GetSpan() *Span {
	if m != nil {
		return m.Span
	}
	return nil
}

func (m *ProtoScenario) GetExecutionStatus() ExecutionStatus {
	if m != nil {
		return m.ExecutionStatus
	}
	return ExecutionStatus_NOTEXECUTED
}

func (m *ProtoScenario) GetPreHookMessages() []string {
	if m != nil {
		return m.PreHookMessages
	}
	return nil
}

func (m *ProtoScenario) GetPostHookMessages() []string {
	if m != nil {
		return m.PostHookMessages
	}
	return nil
}

// / A proto object representing a Span of content
type Span struct {
	Start     int64 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"`
	End       int64 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`
	StartChar int64 `protobuf:"varint,3,opt,name=startChar" json:"startChar,omitempty"`
	EndChar   int64 `protobuf:"varint,4,opt,name=endChar" json:"endChar,omitempty"`
}

func (m *Span) Reset()                    { *m = Span{} }
func (m *Span) String() string            { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()               {}
func (*Span) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *Span) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Span) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Span) GetStartChar() int64 {
	if m != nil {
		return m.StartChar
	}
	return 0
}

func (m *Span) GetEndChar() int64 {
	if m != nil {
		return m.EndChar
	}
	return 0
}

// / A proto object representing a TableDrivenScenario
type ProtoTableDrivenScenario struct {
	// / Scenario under Table driven execution
	Scenario *ProtoScenario `protobuf:"bytes,1,opt,name=scenario" json:"scenario,omitempty"`
	// / Row Index of data table against which the current scenario is executed
	TableRowIndex int32 `protobuf:"varint,2,opt,name=tableRowIndex" json:"tableRowIndex,omitempty"`
}

func (m *ProtoTableDrivenScenario) Reset()                    { *m = ProtoTableDrivenScenario{} }
func (m *ProtoTableDrivenScenario) String() string            { return proto.CompactTextString(m) }
func (*ProtoTableDrivenScenario) ProtoMessage()               {}
func (*ProtoTableDrivenScenario) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *ProtoTableDrivenScenario) GetScenario() *ProtoScenario {
	if m != nil {
		return m.Scenario
	}
	return nil
}

func (m *ProtoTableDrivenScenario) GetTableRowIndex() int32 {
	if m != nil {
		return m.TableRowIndex
	}
	return 0
}

// / A proto object representing a Step
type ProtoStep struct {
	// / Holds the raw text of the Step as defined in the spec file. This contains the actual parameter values.
	ActualText string `protobuf:"bytes,1,opt,name=actualText" json:"actualText,omitempty"`
	// / Contains the parsed text of the Step. This will have placeholders for the parameters.
	ParsedText string `protobuf:"bytes,2,opt,name=parsedText" json:"parsedText,omitempty"`
	// / Collection of a list of fragments for a Step. A fragment could be either text or parameter.
	Fragments []*Fragment `protobuf:"bytes,3,rep,name=fragments" json:"fragments,omitempty"`
	// / Holds the result from the execution.
	StepExecutionResult *ProtoStepExecutionResult `protobuf:"bytes,4,opt,name=stepExecutionResult" json:"stepExecutionResult,omitempty"`
	// / Additional information at pre hook exec time to be available on reports
	PreHookMessages []string `protobuf:"bytes,5,rep,name=preHookMessages" json:"preHookMessages,omitempty"`
	// / Additional information at post hook exec time to be available on reports
	PostHookMessages []string `protobuf:"bytes,6,rep,name=postHookMessages" json:"postHookMessages,omitempty"`
}

func (m *ProtoStep) Reset()                    { *m = ProtoStep{} }
func (m *ProtoStep) String() string            { return proto.CompactTextString(m) }
func (*ProtoStep) ProtoMessage()               {}
func (*ProtoStep) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *ProtoStep) GetActualText() string {
	if m != nil {
		return m.ActualText
	}
	return ""
}

func (m *ProtoStep) GetParsedText() string {
	if m != nil {
		return m.ParsedText
	}
	return ""
}

func (m *ProtoStep) GetFragments() []*Fragment {
	if m != nil {
		return m.Fragments
	}
	return nil
}

func (m *ProtoStep) GetStepExecutionResult() *ProtoStepExecutionResult {
	if m != nil {
		return m.StepExecutionResult
	}
	return nil
}

func (m *ProtoStep) GetPreHookMessages() []string {
	if m != nil {
		return m.PreHookMessages
	}
	return nil
}

func (m *ProtoStep) GetPostHookMessages() []string {
	if m != nil {
		return m.PostHookMessages
	}
	return nil
}

// / Concept is a type of step, that can have multiple Steps.
// / But from a caller's perspective, it is still used as any other Step
// / A proto object representing a Concept
type ProtoConcept struct {
	// / Represents the Step value of a Concept.
	ConceptStep *ProtoStep `protobuf:"bytes,1,opt,name=conceptStep" json:"conceptStep,omitempty"`
	// / Collection of Steps in the given concepts.
	Steps []*ProtoItem `protobuf:"bytes,2,rep,name=steps" json:"steps,omitempty"`
	// / Holds the execution result.
	ConceptExecutionResult *ProtoStepExecutionResult `protobuf:"bytes,3,opt,name=conceptExecutionResult" json:"conceptExecutionResult,omitempty"`
}

func (m *ProtoConcept) Reset()                    { *m = ProtoConcept{} }
func (m *ProtoConcept) String() string            { return proto.CompactTextString(m) }
func (*ProtoConcept) ProtoMessage()               {}
func (*ProtoConcept) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *ProtoConcept) GetConceptStep() *ProtoStep {
	if m != nil {
		return m.ConceptStep
	}
	return nil
}

func (m *ProtoConcept) GetSteps() []*ProtoItem {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *ProtoConcept) GetConceptExecutionResult() *ProtoStepExecutionResult {
	if m != nil {
		return m.ConceptExecutionResult
	}
	return nil
}

// / A proto object representing Tags
type ProtoTags struct {
	// / A collection of Tags
	Tags []string `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
}

func (m *ProtoTags) Reset()                    { *m = ProtoTags{} }
func (m *ProtoTags) String() string            { return proto.CompactTextString(m) }
func (*ProtoTags) ProtoMessage()               {}
func (*ProtoTags) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

func (m *ProtoTags) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// / A proto object representing Fragment.
// / Fragments, put together make up A Step
type Fragment struct {
	// / Type of Fragment, valid values are Text, Parameter
	FragmentType Fragment_FragmentType `protobuf:"varint,1,opt,name=fragmentType,enum=gauge.messages.Fragment_FragmentType" json:"fragmentType,omitempty"`
	// / Text part of the Fragment, valid only if FragmentType=Text
	Text string `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
	// / Parameter part of the Fragment, valid only if FragmentType=Parameter
	Parameter *Parameter `protobuf:"bytes,3,opt,name=parameter" json:"parameter,omitempty"`
}

func (m *Fragment) Reset()                    { *m = Fragment{} }
func (m *Fragment) String() string            { return proto.CompactTextString(m) }
func (*Fragment) ProtoMessage()               {}
func (*Fragment) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{8} }

func (m *Fragment) GetFragmentType() Fragment_FragmentType {
	if m != nil {
		return m.FragmentType
	}
	return Fragment_Text
}

func (m *Fragment) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Fragment) GetParameter() *Parameter {
	if m != nil {
		return m.Parameter
	}
	return nil
}

// / A proto object representing Fragment.
type Parameter struct {
	// / Type of the Parameter. Valid values: Static, Dynamic, Special_String, Special_Table, Table
	ParameterType Parameter_ParameterType `protobuf:"varint,1,opt,name=parameterType,enum=gauge.messages.Parameter_ParameterType" json:"parameterType,omitempty"`
	// / Holds the value of the parameter
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	// / Holds the name of the parameter, used as Key to lookup the value.
	Name string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// / Holds the table value, if parameterType=Table or Special_Table
	Table *ProtoTable `protobuf:"bytes,4,opt,name=table" json:"table,omitempty"`
}

func (m *Parameter) Reset()                    { *m = Parameter{} }
func (m *Parameter) String() string            { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()               {}
func (*Parameter) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{9} }

func (m *Parameter) GetParameterType() Parameter_ParameterType {
	if m != nil {
		return m.ParameterType
	}
	return Parameter_Static
}

func (m *Parameter) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Parameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Parameter) GetTable() *ProtoTable {
	if m != nil {
		return m.Table
	}
	return nil
}

// / A proto object representing Comment.
type ProtoComment struct {
	// / Text representing the Comment.
	Text string `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
}

func (m *ProtoComment) Reset()                    { *m = ProtoComment{} }
func (m *ProtoComment) String() string            { return proto.CompactTextString(m) }
func (*ProtoComment) ProtoMessage()               {}
func (*ProtoComment) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{10} }

func (m *ProtoComment) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// / A proto object representing Table.
type ProtoTable struct {
	// / Contains the Headers for the table
	Headers *ProtoTableRow `protobuf:"bytes,1,opt,name=headers" json:"headers,omitempty"`
	// / Contains the Rows for the table
	Rows []*ProtoTableRow `protobuf:"bytes,2,rep,name=rows" json:"rows,omitempty"`
}

func (m *ProtoTable) Reset()                    { *m = ProtoTable{} }
func (m *ProtoTable) String() string            { return proto.CompactTextString(m) }
func (*ProtoTable) ProtoMessage()               {}
func (*ProtoTable) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{11} }

func (m *ProtoTable) GetHeaders() *ProtoTableRow {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *ProtoTable) GetRows() []*ProtoTableRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

// / A proto object representing Table.
type ProtoTableRow struct {
	// / Represents the cells of a given table
	Cells []string `protobuf:"bytes,1,rep,name=cells" json:"cells,omitempty"`
}

func (m *ProtoTableRow) Reset()                    { *m = ProtoTableRow{} }
func (m *ProtoTableRow) String() string            { return proto.CompactTextString(m) }
func (*ProtoTableRow) ProtoMessage()               {}
func (*ProtoTableRow) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{12} }

func (m *ProtoTableRow) GetCells() []string {
	if m != nil {
		return m.Cells
	}
	return nil
}

// / A proto object representing Step Execution result
type ProtoStepExecutionResult struct {
	// / The actual result of the execution
	ExecutionResult *ProtoExecutionResult `protobuf:"bytes,1,opt,name=executionResult" json:"executionResult,omitempty"`
	// / Contains a 'before' hook failure message. This happens when the `before_step` hook has an error.
	PreHookFailure *ProtoHookFailure `protobuf:"bytes,2,opt,name=preHookFailure" json:"preHookFailure,omitempty"`
	// / Contains a 'after' hook failure message. This happens when the `after_step` hook has an error.
	PostHookFailure *ProtoHookFailure `protobuf:"bytes,3,opt,name=postHookFailure" json:"postHookFailure,omitempty"`
	Skipped         bool              `protobuf:"varint,4,opt,name=skipped" json:"skipped,omitempty"`
	SkippedReason   string            `protobuf:"bytes,5,opt,name=skippedReason" json:"skippedReason,omitempty"`
}

func (m *ProtoStepExecutionResult) Reset()                    { *m = ProtoStepExecutionResult{} }
func (m *ProtoStepExecutionResult) String() string            { return proto.CompactTextString(m) }
func (*ProtoStepExecutionResult) ProtoMessage()               {}
func (*ProtoStepExecutionResult) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{13} }

func (m *ProtoStepExecutionResult) GetExecutionResult() *ProtoExecutionResult {
	if m != nil {
		return m.ExecutionResult
	}
	return nil
}

func (m *ProtoStepExecutionResult) GetPreHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PreHookFailure
	}
	return nil
}

func (m *ProtoStepExecutionResult) GetPostHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PostHookFailure
	}
	return nil
}

func (m *ProtoStepExecutionResult) GetSkipped() bool {
	if m != nil {
		return m.Skipped
	}
	return false
}

func (m *ProtoStepExecutionResult) GetSkippedReason() string {
	if m != nil {
		return m.SkippedReason
	}
	return ""
}

// / A proto object representing the result of an execution
type ProtoExecutionResult struct {
	// / Flag to indicate failure
	Failed bool `protobuf:"varint,1,opt,name=failed" json:"failed,omitempty"`
	// / Flag to indicate if the error is recoverable from.
	RecoverableError bool `protobuf:"varint,2,opt,name=recoverableError" json:"recoverableError,omitempty"`
	// / The actual error message.
	ErrorMessage string `protobuf:"bytes,3,opt,name=errorMessage" json:"errorMessage,omitempty"`
	// / Stacktrace of the error
	StackTrace string `protobuf:"bytes,4,opt,name=stackTrace" json:"stackTrace,omitempty"`
	// / Byte array containing screenshot taken at the time of failure.
	ScreenShot []byte `protobuf:"bytes,5,opt,name=screenShot,proto3" json:"screenShot,omitempty"`
	// / Holds the time taken for executing this scenario.
	ExecutionTime int64 `protobuf:"varint,6,opt,name=executionTime" json:"executionTime,omitempty"`
	// / Additional information at exec time to be available on reports
	Message []string `protobuf:"bytes,7,rep,name=message" json:"message,omitempty"`
	// / Type of the Error. Valid values: ASSERTION, VERIFICATION. Default: ASSERTION
	ErrorType ProtoExecutionResult_ErrorType `protobuf:"varint,8,opt,name=errorType,enum=gauge.messages.ProtoExecutionResult_ErrorType" json:"errorType,omitempty"`
}

func (m *ProtoExecutionResult) Reset()                    { *m = ProtoExecutionResult{} }
func (m *ProtoExecutionResult) String() string            { return proto.CompactTextString(m) }
func (*ProtoExecutionResult) ProtoMessage()               {}
func (*ProtoExecutionResult) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{14} }

func (m *ProtoExecutionResult) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *ProtoExecutionResult) GetRecoverableError() bool {
	if m != nil {
		return m.RecoverableError
	}
	return false
}

func (m *ProtoExecutionResult) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *ProtoExecutionResult) GetStackTrace() string {
	if m != nil {
		return m.StackTrace
	}
	return ""
}

func (m *ProtoExecutionResult) GetScreenShot() []byte {
	if m != nil {
		return m.ScreenShot
	}
	return nil
}

func (m *ProtoExecutionResult) GetExecutionTime() int64 {
	if m != nil {
		return m.ExecutionTime
	}
	return 0
}

func (m *ProtoExecutionResult) GetMessage() []string {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *ProtoExecutionResult) GetErrorType() ProtoExecutionResult_ErrorType {
	if m != nil {
		return m.ErrorType
	}
	return ProtoExecutionResult_ASSERTION
}

// / A proto object representing a pre-hook failure.
// / Used to hold failure information for before_suite, before_spec, before_scenario and before_spec hooks.
type ProtoHookFailure struct {
	// / Stacktrace from the failure
	StackTrace string `protobuf:"bytes,1,opt,name=stackTrace" json:"stackTrace,omitempty"`
	// / Error message from the failure
	ErrorMessage string `protobuf:"bytes,2,opt,name=errorMessage" json:"errorMessage,omitempty"`
	// / Byte array holding the screenshot taken at the time of failure.
	ScreenShot []byte `protobuf:"bytes,3,opt,name=screenShot,proto3" json:"screenShot,omitempty"`
	// / Contains table row index corresponding to datatable rows
	TableRowIndex int32 `protobuf:"varint,4,opt,name=tableRowIndex" json:"tableRowIndex,omitempty"`
}

func (m *ProtoHookFailure) Reset()                    { *m = ProtoHookFailure{} }
func (m *ProtoHookFailure) String() string            { return proto.CompactTextString(m) }
func (*ProtoHookFailure) ProtoMessage()               {}
func (*ProtoHookFailure) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{15} }

func (m *ProtoHookFailure) GetStackTrace() string {
	if m != nil {
		return m.StackTrace
	}
	return ""
}

func (m *ProtoHookFailure) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *ProtoHookFailure) GetScreenShot() []byte {
	if m != nil {
		return m.ScreenShot
	}
	return nil
}

func (m *ProtoHookFailure) GetTableRowIndex() int32 {
	if m != nil {
		return m.TableRowIndex
	}
	return 0
}

// / A proto object representing the result of entire Suite execution.
type ProtoSuiteResult struct {
	// / Contains the result from the execution
	SpecResults []*ProtoSpecResult `protobuf:"bytes,1,rep,name=specResults" json:"specResults,omitempty"`
	// / Contains a 'before' hook failure message. This happens when the `before_suite` hook has an error
	PreHookFailure *ProtoHookFailure `protobuf:"bytes,2,opt,name=preHookFailure" json:"preHookFailure,omitempty"`
	// / Contains a 'after' hook failure message. This happens when the `after_suite` hook has an error
	PostHookFailure *ProtoHookFailure `protobuf:"bytes,3,opt,name=postHookFailure" json:"postHookFailure,omitempty"`
	// / Flag to indicate failure
	Failed bool `protobuf:"varint,4,opt,name=failed" json:"failed,omitempty"`
	// / Holds the count of number of Specifications that failed.
	SpecsFailedCount int32 `protobuf:"varint,5,opt,name=specsFailedCount" json:"specsFailedCount,omitempty"`
	// / Holds the time taken for executing the whole suite.
	ExecutionTime int64 `protobuf:"varint,6,opt,name=executionTime" json:"executionTime,omitempty"`
	// / Holds a metric indicating the success rate of the execution.
	SuccessRate float32 `protobuf:"fixed32,7,opt,name=successRate" json:"successRate,omitempty"`
	// / The environment against which execution was done
	Environment string `protobuf:"bytes,8,opt,name=environment" json:"environment,omitempty"`
	// / Tag expression used for filtering specification
	Tags string `protobuf:"bytes,9,opt,name=tags" json:"tags,omitempty"`
	// / Project name
	ProjectName string `protobuf:"bytes,10,opt,name=projectName" json:"projectName,omitempty"`
	// / Timestamp of when execution started
	Timestamp         string `protobuf:"bytes,11,opt,name=timestamp" json:"timestamp,omitempty"`
	SpecsSkippedCount int32  `protobuf:"varint,12,opt,name=specsSkippedCount" json:"specsSkippedCount,omitempty"`
	// / Additional information at pre hook exec time to be available on reports
	PreHookMessages []string `protobuf:"bytes,13,rep,name=preHookMessages" json:"preHookMessages,omitempty"`
	// / Additional information at post hook exec time to be available on reports
	PostHookMessages []string `protobuf:"bytes,14,rep,name=postHookMessages" json:"postHookMessages,omitempty"`
}

func (m *ProtoSuiteResult) Reset()                    { *m = ProtoSuiteResult{} }
func (m *ProtoSuiteResult) String() string            { return proto.CompactTextString(m) }
func (*ProtoSuiteResult) ProtoMessage()               {}
func (*ProtoSuiteResult) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{16} }

func (m *ProtoSuiteResult) GetSpecResults() []*ProtoSpecResult {
	if m != nil {
		return m.SpecResults
	}
	return nil
}

func (m *ProtoSuiteResult) GetPreHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PreHookFailure
	}
	return nil
}

func (m *ProtoSuiteResult) GetPostHookFailure() *ProtoHookFailure {
	if m != nil {
		return m.PostHookFailure
	}
	return nil
}

func (m *ProtoSuiteResult) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *ProtoSuiteResult) GetSpecsFailedCount() int32 {
	if m != nil {
		return m.SpecsFailedCount
	}
	return 0
}

func (m *ProtoSuiteResult) GetExecutionTime() int64 {
	if m != nil {
		return m.ExecutionTime
	}
	return 0
}

func (m *ProtoSuiteResult) GetSuccessRate() float32 {
	if m != nil {
		return m.SuccessRate
	}
	return 0
}

func (m *ProtoSuiteResult) GetEnvironment() string {
	if m != nil {
		return m.Environment
	}
	return ""
}

func (m *ProtoSuiteResult) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *ProtoSuiteResult) GetProjectName() string {
	if m != nil {
		return m.ProjectName
	}
	return ""
}

func (m *ProtoSuiteResult) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *ProtoSuiteResult) GetSpecsSkippedCount() int32 {
	if m != nil {
		return m.SpecsSkippedCount
	}
	return 0
}

func (m *ProtoSuiteResult) GetPreHookMessages() []string {
	if m != nil {
		return m.PreHookMessages
	}
	return nil
}

func (m *ProtoSuiteResult) GetPostHookMessages() []string {
	if m != nil {
		return m.PostHookMessages
	}
	return nil
}

// / A proto object representing the result of Spec execution.
type ProtoSpecResult struct {
	// / Represents the corresponding Specification
	ProtoSpec *ProtoSpec `protobuf:"bytes,1,opt,name=protoSpec" json:"protoSpec,omitempty"`
	// / Holds the number of Scenarios executed
	ScenarioCount int32 `protobuf:"varint,2,opt,name=scenarioCount" json:"scenarioCount,omitempty"`
	// / Holds the number of Scenarios failed
	ScenarioFailedCount int32 `protobuf:"varint,3,opt,name=scenarioFailedCount" json:"scenarioFailedCount,omitempty"`
	// / Flag to indicate failure
	Failed bool `protobuf:"varint,4,opt,name=failed" json:"failed,omitempty"`
	// / Holds the row numbers, which caused the execution to fail.
	FailedDataTableRows []int32 `protobuf:"varint,5,rep,packed,name=failedDataTableRows" json:"failedDataTableRows,omitempty"`
	// / Holds the time taken for executing the spec.
	ExecutionTime int64 `protobuf:"varint,6,opt,name=executionTime" json:"executionTime,omitempty"`
	// / Flag to indicate if spec is skipped
	Skipped bool `protobuf:"varint,7,opt,name=skipped" json:"skipped,omitempty"`
	// / Holds the number of Scenarios skipped
	ScenarioSkippedCount int32 `protobuf:"varint,8,opt,name=scenarioSkippedCount" json:"scenarioSkippedCount,omitempty"`
	// / Holds the row numbers, for which the execution skipped.
	SkippedDataTableRows []int32 `protobuf:"varint,9,rep,packed,name=skippedDataTableRows" json:"skippedDataTableRows,omitempty"`
	// / Holds parse, validation and skipped errors.
	Errors []*Error `protobuf:"bytes,10,rep,name=errors" json:"errors,omitempty"`
}

func (m *ProtoSpecResult) Reset()                    { *m = ProtoSpecResult{} }
func (m *ProtoSpecResult) String() string            { return proto.CompactTextString(m) }
func (*ProtoSpecResult) ProtoMessage()               {}
func (*ProtoSpecResult) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{17} }

func (m *ProtoSpecResult) GetProtoSpec() *ProtoSpec {
	if m != nil {
		return m.ProtoSpec
	}
	return nil
}

func (m *ProtoSpecResult) GetScenarioCount() int32 {
	if m != nil {
		return m.ScenarioCount
	}
	return 0
}

func (m *ProtoSpecResult) GetScenarioFailedCount() int32 {
	if m != nil {
		return m.ScenarioFailedCount
	}
	return 0
}

func (m *ProtoSpecResult) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *ProtoSpecResult) GetFailedDataTableRows() []int32 {
	if m != nil {
		return m.FailedDataTableRows
	}
	return nil
}

func (m *ProtoSpecResult) GetExecutionTime() int64 {
	if m != nil {
		return m.ExecutionTime
	}
	return 0
}

func (m *ProtoSpecResult) GetSkipped() bool {
	if m != nil {
		return m.Skipped
	}
	return false
}

func (m *ProtoSpecResult) GetScenarioSkippedCount() int32 {
	if m != nil {
		return m.ScenarioSkippedCount
	}
	return 0
}

func (m *ProtoSpecResult) GetSkippedDataTableRows() []int32 {
	if m != nil {
		return m.SkippedDataTableRows
	}
	return nil
}

func (m *ProtoSpecResult) GetErrors() []*Error {
	if m != nil {
		return m.Errors
	}
	return nil
}

// / A proto object representing an error in spec/Scenario.
type Error struct {
	// / Holds the type of error
	Type Error_ErrorType `protobuf:"varint,1,opt,name=type,enum=gauge.messages.Error_ErrorType" json:"type,omitempty"`
	// / Holds the filename.
	Filename string `protobuf:"bytes,2,opt,name=filename" json:"filename,omitempty"`
	// / Holds the line number of the error in file.
	LineNumber int32 `protobuf:"varint,3,opt,name=lineNumber" json:"lineNumber,omitempty"`
	// / Holds the error message.
	Message string `protobuf:"bytes,4,opt,name=message" json:"message,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{18} }

func (m *Error) GetType() Error_ErrorType {
	if m != nil {
		return m.Type
	}
	return Error_PARSE_ERROR
}

func (m *Error) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *Error) GetLineNumber() int32 {
	if m != nil {
		return m.LineNumber
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// / A proto object representing a Step value.
type ProtoStepValue struct {
	// / The actual string value describing he Step
	StepValue string `protobuf:"bytes,1,opt,name=stepValue" json:"stepValue,omitempty"`
	// / The parameterized string value describing he Step. The parameters are replaced with placeholders.
	ParameterizedStepValue string `protobuf:"bytes,2,opt,name=parameterizedStepValue" json:"parameterizedStepValue,omitempty"`
	// / A collection of strings representing the parameters.
	Parameters []string `protobuf:"bytes,3,rep,name=parameters" json:"parameters,omitempty"`
}

func (m *ProtoStepValue) Reset()                    { *m = ProtoStepValue{} }
func (m *ProtoStepValue) String() string            { return proto.CompactTextString(m) }
func (*ProtoStepValue) ProtoMessage()               {}
func (*ProtoStepValue) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{19} }

func (m *ProtoStepValue) GetStepValue() string {
	if m != nil {
		return m.StepValue
	}
	return ""
}

func (m *ProtoStepValue) GetParameterizedStepValue() string {
	if m != nil {
		return m.ParameterizedStepValue
	}
	return ""
}

func (m *ProtoStepValue) GetParameters() []string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func init() {
	proto.RegisterType((*ProtoSpec)(nil), "gauge.messages.ProtoSpec")
	proto.RegisterType((*ProtoItem)(nil), "gauge.messages.ProtoItem")
	proto.RegisterType((*ProtoScenario)(nil), "gauge.messages.ProtoScenario")
	proto.RegisterType((*Span)(nil), "gauge.messages.Span")
	proto.RegisterType((*ProtoTableDrivenScenario)(nil), "gauge.messages.ProtoTableDrivenScenario")
	proto.RegisterType((*ProtoStep)(nil), "gauge.messages.ProtoStep")
	proto.RegisterType((*ProtoConcept)(nil), "gauge.messages.ProtoConcept")
	proto.RegisterType((*ProtoTags)(nil), "gauge.messages.ProtoTags")
	proto.RegisterType((*Fragment)(nil), "gauge.messages.Fragment")
	proto.RegisterType((*Parameter)(nil), "gauge.messages.Parameter")
	proto.RegisterType((*ProtoComment)(nil), "gauge.messages.ProtoComment")
	proto.RegisterType((*ProtoTable)(nil), "gauge.messages.ProtoTable")
	proto.RegisterType((*ProtoTableRow)(nil), "gauge.messages.ProtoTableRow")
	proto.RegisterType((*ProtoStepExecutionResult)(nil), "gauge.messages.ProtoStepExecutionResult")
	proto.RegisterType((*ProtoExecutionResult)(nil), "gauge.messages.ProtoExecutionResult")
	proto.RegisterType((*ProtoHookFailure)(nil), "gauge.messages.ProtoHookFailure")
	proto.RegisterType((*ProtoSuiteResult)(nil), "gauge.messages.ProtoSuiteResult")
	proto.RegisterType((*ProtoSpecResult)(nil), "gauge.messages.ProtoSpecResult")
	proto.RegisterType((*Error)(nil), "gauge.messages.Error")
	proto.RegisterType((*ProtoStepValue)(nil), "gauge.messages.ProtoStepValue")
	proto.RegisterEnum("gauge.messages.ExecutionStatus", ExecutionStatus_name, ExecutionStatus_value)
	proto.RegisterEnum("gauge.messages.ProtoItem_ItemType", ProtoItem_ItemType_name, ProtoItem_ItemType_value)
	proto.RegisterEnum("gauge.messages.Fragment_FragmentType", Fragment_FragmentType_name, Fragment_FragmentType_value)
	proto.RegisterEnum("gauge.messages.Parameter_ParameterType", Parameter_ParameterType_name, Parameter_ParameterType_value)
	proto.RegisterEnum("gauge.messages.ProtoExecutionResult_ErrorType", ProtoExecutionResult_ErrorType_name, ProtoExecutionResult_ErrorType_value)
	proto.RegisterEnum("gauge.messages.Error_ErrorType", Error_ErrorType_name, Error_ErrorType_value)
}

func init() { proto.RegisterFile("spec.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 1791 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcb, 0x6f, 0x1c, 0x49,
	0x19, 0x77, 0x3f, 0xc6, 0x33, 0xf3, 0xcd, 0xc3, 0x9d, 0x8a, 0x09, 0x4d, 0x14, 0x92, 0x51, 0xcb,
	0xab, 0xb5, 0xa2, 0x5d, 0x13, 0xbc, 0x22, 0x2b, 0x84, 0x04, 0xf2, 0x7a, 0xc6, 0x9b, 0x81, 0xac,
	0x63, 0xd5, 0x0c, 0x11, 0xda, 0xcb, 0x52, 0x69, 0x57, 0x9c, 0xde, 0xcc, 0x74, 0xb7, 0xba, 0x6b,
	0x12, 0x2f, 0xdc, 0xf9, 0x03, 0x38, 0x73, 0xe4, 0xc4, 0x9d, 0x3b, 0x12, 0x12, 0x17, 0x24, 0xfe,
	0x04, 0xfe, 0x07, 0x4e, 0x48, 0x9c, 0x50, 0x7d, 0x55, 0xfd, 0x9c, 0x9e, 0x78, 0x82, 0x38, 0xec,
	0xad, 0xea, 0x7b, 0x54, 0xd7, 0xf7, 0xa8, 0x5f, 0xfd, 0xaa, 0x01, 0xd2, 0x98, 0xfb, 0x47, 0x71,
	0x12, 0x89, 0x88, 0x0c, 0xaf, 0xd8, 0xea, 0x8a, 0x1f, 0x2d, 0x79, 0x9a, 0xb2, 0x2b, 0x9e, 0x7a,
	0x7f, 0xb4, 0xa0, 0x7b, 0x21, 0x35, 0xb3, 0x98, 0xfb, 0x64, 0x04, 0x3d, 0x69, 0xfb, 0x84, 0xb3,
	0xcb, 0x20, 0xbc, 0x72, 0x8d, 0x91, 0x71, 0xd8, 0xa5, 0x65, 0x11, 0xf9, 0x01, 0xb4, 0x02, 0xc1,
	0x97, 0xa9, 0x6b, 0x8e, 0xac, 0xc3, 0xde, 0xf1, 0xf7, 0x8e, 0xaa, 0xeb, 0x1d, 0xe1, 0x5a, 0x53,
	0xc1, 0x97, 0x54, 0xd9, 0x91, 0x03, 0x18, 0x04, 0xe9, 0x9c, 0xbd, 0x58, 0xf0, 0x71, 0x12, 0xbc,
	0xe1, 0xa1, 0x6b, 0x8d, 0x8c, 0xc3, 0x0e, 0xad, 0x0a, 0xc9, 0xcf, 0x61, 0x2f, 0x4e, 0xf8, 0x93,
	0x28, 0x7a, 0x7d, 0xc6, 0x82, 0xc5, 0x2a, 0xe1, 0xa9, 0x6b, 0xe3, 0x07, 0x46, 0x8d, 0x1f, 0x28,
	0x19, 0xd2, 0xba, 0x23, 0x79, 0x0a, 0x4e, 0x1c, 0xa5, 0xa2, 0xb2, 0x58, 0x6b, 0xcb, 0xc5, 0xd6,
	0x3c, 0xc9, 0x5d, 0xe8, 0xbc, 0x0c, 0x16, 0xfc, 0x9c, 0x2d, 0xb9, 0xbb, 0x8b, 0xf9, 0xc8, 0xe7,
	0x84, 0x80, 0x2d, 0xd8, 0x55, 0xea, 0xb6, 0x47, 0xd6, 0x61, 0x97, 0xe2, 0x98, 0x1c, 0xe6, 0x91,
	0x7c, 0xa1, 0xbf, 0xe2, 0x76, 0x50, 0x5d, 0x17, 0x93, 0x87, 0xc5, 0x3e, 0x73, 0xd3, 0x2e, 0x9a,
	0xae, 0xc9, 0xbd, 0x7f, 0xd8, 0xba, 0x4c, 0x32, 0xb5, 0xe4, 0xa7, 0xd0, 0x91, 0xc9, 0x9d, 0x7f,
	0x13, 0x73, 0xac, 0xd1, 0xf0, 0xd8, 0xdb, 0x58, 0x87, 0xa3, 0xa9, 0xb6, 0xa4, 0xb9, 0x0f, 0xf9,
	0x18, 0xec, 0x54, 0xf0, 0xd8, 0x35, 0x47, 0xc6, 0xc6, 0x1a, 0xce, 0x04, 0x8f, 0x29, 0x9a, 0x91,
	0xc7, 0xd0, 0xf6, 0xa3, 0xd0, 0xe7, 0xb1, 0xc0, 0xe2, 0xf5, 0x8e, 0xef, 0x35, 0x7a, 0x9c, 0x2a,
	0x1b, 0x9a, 0x19, 0x93, 0x1f, 0x43, 0x27, 0xf5, 0x79, 0xc8, 0x92, 0x20, 0x72, 0x6d, 0x74, 0xfc,
	0x7e, 0xf3, 0xa7, 0xb4, 0x11, 0xcd, 0xcd, 0xc9, 0x97, 0x70, 0x5b, 0x14, 0xed, 0x91, 0x19, 0xb8,
	0x2d, 0x5c, 0xe5, 0xb0, 0x71, 0x95, 0xf9, 0xba, 0x3d, 0x6d, 0x5a, 0x44, 0x85, 0xb3, 0x5c, 0xf2,
	0x50, 0x60, 0x41, 0x37, 0x87, 0x83, 0x36, 0x34, 0x33, 0x26, 0x8f, 0xa0, 0x85, 0xcb, 0xb9, 0x6d,
	0xf4, 0xba, 0xbb, 0x79, 0x17, 0x54, 0x19, 0xca, 0x3c, 0x63, 0x7f, 0x74, 0xde, 0x91, 0xe7, 0x39,
	0xbb, 0x4a, 0x55, 0xeb, 0x78, 0x5f, 0x43, 0x27, 0x2b, 0x16, 0xe9, 0x80, 0x2d, 0x2b, 0xe0, 0xec,
	0x90, 0x1e, 0xb4, 0xf5, 0x56, 0x1c, 0x43, 0x4d, 0x30, 0xbb, 0x8e, 0x49, 0xfa, 0xd0, 0xc9, 0x82,
	0x72, 0x2c, 0xf2, 0x5d, 0xb8, 0xdd, 0x90, 0x02, 0xc7, 0x26, 0x5d, 0x68, 0xa1, 0xc2, 0x69, 0xc9,
	0x55, 0xe5, 0xf7, 0x9c, 0x5d, 0xef, 0xdf, 0x2d, 0x18, 0x54, 0x92, 0x2f, 0x1b, 0x37, 0x4b, 0x7f,
	0xf5, 0xfc, 0xd7, 0xc5, 0xe4, 0x2e, 0xec, 0xbe, 0x64, 0xc1, 0x82, 0x5f, 0x62, 0x03, 0x75, 0x3e,
	0x33, 0x5d, 0x83, 0x6a, 0x09, 0xf9, 0x11, 0x74, 0xfc, 0x28, 0x14, 0xfc, 0x5a, 0xa4, 0xae, 0x75,
	0x13, 0x44, 0xe4, 0xa6, 0xe4, 0x67, 0x30, 0xc8, 0xbe, 0x32, 0x45, 0x78, 0xb1, 0x6f, 0xf2, 0xad,
	0xda, 0x93, 0x27, 0x30, 0xac, 0xe2, 0x80, 0xee, 0x95, 0x9b, 0x8f, 0x7c, 0xcd, 0x0f, 0xa1, 0xa8,
	0x0a, 0x02, 0xba, 0x4d, 0xb6, 0x81, 0xa2, 0xaa, 0x63, 0x23, 0x40, 0x1c, 0xc0, 0x80, 0x5f, 0x73,
	0x7f, 0x25, 0x82, 0x28, 0x9c, 0x07, 0x4b, 0x8e, 0xdd, 0x61, 0xd1, 0xaa, 0x90, 0xdc, 0x83, 0x76,
	0xfa, 0x3a, 0x88, 0x63, 0x7e, 0xe9, 0x76, 0xf3, 0x24, 0x67, 0x22, 0x72, 0x1f, 0x40, 0x0e, 0x27,
	0x49, 0x12, 0x25, 0xa9, 0x0b, 0xb8, 0x7a, 0x49, 0x42, 0x86, 0x60, 0x4e, 0xc7, 0x6e, 0x0f, 0xcb,
	0x67, 0x4e, 0xc7, 0x32, 0xbd, 0x82, 0xb3, 0x64, 0x1c, 0xbd, 0x0d, 0x65, 0x57, 0xa5, 0x6e, 0xff,
	0xc6, 0xf4, 0x56, 0xec, 0xc9, 0x21, 0xd8, 0x69, 0xcc, 0x42, 0x77, 0x80, 0x99, 0xd8, 0xaf, 0xfb,
	0xcd, 0x62, 0x16, 0x52, 0xb4, 0x20, 0x53, 0xd8, 0xcb, 0x23, 0x99, 0x09, 0x26, 0x56, 0xa9, 0x3b,
	0x44, 0x88, 0x7a, 0x50, 0x77, 0x9a, 0x54, 0xcd, 0x68, 0xdd, 0xaf, 0x09, 0x4a, 0xf7, 0xb6, 0x87,
	0x52, 0x67, 0x03, 0x94, 0xbe, 0x04, 0x5b, 0x6e, 0x97, 0xec, 0x43, 0x2b, 0x15, 0x2c, 0x11, 0xd8,
	0xe5, 0x16, 0x55, 0x13, 0xe2, 0x80, 0xc5, 0x43, 0xd5, 0xd8, 0x16, 0x95, 0x43, 0x72, 0x0f, 0xba,
	0xa8, 0x3a, 0x7d, 0xc5, 0x12, 0xc4, 0x3f, 0x8b, 0x16, 0x02, 0xe2, 0x42, 0x9b, 0x87, 0x97, 0xa8,
	0xb3, 0x51, 0x97, 0x4d, 0xbd, 0xdf, 0x82, 0xbb, 0x09, 0x97, 0x2a, 0xc8, 0x68, 0xbc, 0x1f, 0x32,
	0x1e, 0xc0, 0x00, 0xc1, 0x85, 0x46, 0x6f, 0xa7, 0xe1, 0x25, 0xbf, 0xc6, 0xad, 0xb6, 0x68, 0x55,
	0xe8, 0xfd, 0xd9, 0xcc, 0xae, 0x75, 0x09, 0xe0, 0xf7, 0x01, 0x98, 0x2f, 0x56, 0x6c, 0x31, 0xe7,
	0xd7, 0x42, 0x9f, 0xea, 0x92, 0x44, 0xea, 0x63, 0x96, 0xa4, 0xfc, 0x12, 0xf5, 0xa6, 0xd2, 0x17,
	0x12, 0xf2, 0x18, 0xba, 0x2f, 0x13, 0x76, 0x25, 0x31, 0x28, 0x3b, 0xd5, 0x6e, 0x7d, 0xbf, 0x67,
	0xda, 0x80, 0x16, 0xa6, 0x12, 0xc5, 0xe5, 0x05, 0x92, 0x17, 0x9a, 0xf2, 0x74, 0xb5, 0x10, 0xfa,
	0x2e, 0x38, 0xdc, 0x78, 0xed, 0xd4, 0xec, 0x69, 0xd3, 0x22, 0x4d, 0xcd, 0xd1, 0xda, 0xbe, 0x39,
	0x76, 0x37, 0x34, 0xc7, 0x3f, 0x0d, 0xe8, 0x97, 0x2f, 0x33, 0xf2, 0x13, 0xe8, 0xe9, 0xeb, 0x4c,
	0xee, 0x4c, 0x17, 0xeb, 0x1d, 0x37, 0x66, 0xd9, 0x5a, 0x92, 0xa5, 0x14, 0x8f, 0xdb, 0xcd, 0x64,
	0x09, 0xed, 0xc8, 0xaf, 0xe1, 0x8e, 0xf6, 0xaf, 0xe7, 0xcc, 0x7a, 0xcf, 0x9c, 0x6d, 0x58, 0xc7,
	0x7b, 0xa0, 0xfb, 0x42, 0x5e, 0x03, 0x39, 0x3c, 0x19, 0x05, 0x3c, 0x79, 0x7f, 0x37, 0xa0, 0x93,
	0xd5, 0x92, 0x4c, 0xa1, 0x9f, 0x55, 0xb3, 0x44, 0x36, 0x3e, 0xd8, 0x54, 0xfb, 0x7c, 0x80, 0x7c,
	0xa3, 0xe2, 0x8a, 0xdf, 0x2a, 0xba, 0x0b, 0xc7, 0xe4, 0x53, 0xe8, 0xc6, 0x2c, 0x61, 0x4b, 0x2e,
	0x78, 0xa2, 0x23, 0x5c, 0xcf, 0x51, 0x66, 0x40, 0x0b, 0x5b, 0xef, 0x43, 0xe8, 0x97, 0x3f, 0x85,
	0xf7, 0x1a, 0xbf, 0x16, 0xce, 0x0e, 0x19, 0x40, 0x37, 0xf7, 0x70, 0x0c, 0xef, 0xf7, 0x66, 0x69,
	0x4e, 0xbe, 0x80, 0x41, 0xbe, 0x46, 0x29, 0x9e, 0x0f, 0x37, 0x7e, 0xb3, 0x18, 0x61, 0x44, 0x55,
	0x6f, 0x89, 0x20, 0x6f, 0xd8, 0x62, 0xc5, 0x75, 0x4c, 0x6a, 0x22, 0x03, 0x0d, 0x25, 0x59, 0xb4,
	0x54, 0xa0, 0x72, 0x5c, 0x50, 0x07, 0x7b, 0x4b, 0xea, 0xe0, 0x7d, 0x09, 0x83, 0xca, 0xb7, 0x09,
	0xc0, 0xae, 0x84, 0xc5, 0xc0, 0x57, 0x94, 0x60, 0xfc, 0x4d, 0xc8, 0x96, 0x81, 0xef, 0x18, 0x84,
	0xc0, 0x50, 0x72, 0xf7, 0x80, 0x2d, 0xbe, 0x9a, 0x89, 0x24, 0x08, 0xaf, 0x1c, 0x93, 0xdc, 0x82,
	0x41, 0x26, 0x53, 0x57, 0xbf, 0x55, 0xb0, 0x00, 0xdb, 0xf3, 0xf2, 0x1e, 0x57, 0xc4, 0x26, 0x2b,
	0x8d, 0x51, 0x94, 0xc6, 0xbb, 0x06, 0x28, 0x36, 0x45, 0x3e, 0x85, 0xf6, 0x2b, 0xce, 0x2e, 0x79,
	0x92, 0xbe, 0x13, 0xae, 0xe6, 0x1a, 0x83, 0x68, 0x66, 0x4d, 0x7e, 0x08, 0x76, 0x12, 0xbd, 0xcd,
	0x0e, 0xc0, 0x0d, 0x5e, 0x68, 0xea, 0x7d, 0xa0, 0x89, 0x49, 0x26, 0x96, 0x69, 0xf6, 0xf9, 0x62,
	0x91, 0xb5, 0xa9, 0x9a, 0x78, 0x7f, 0x31, 0x35, 0xbe, 0x36, 0x74, 0x3f, 0x39, 0x2f, 0x5d, 0x42,
	0xfa, 0x00, 0xa9, 0x7d, 0x1f, 0x34, 0xee, 0xa0, 0x7e, 0x78, 0xea, 0xce, 0x0d, 0xec, 0xc2, 0xfc,
	0xff, 0xb1, 0x0b, 0xeb, 0x7f, 0x65, 0x17, 0x6e, 0xc1, 0x11, 0x6c, 0x7c, 0x54, 0xe5, 0xfc, 0xe0,
	0x00, 0x06, 0x7a, 0x48, 0x39, 0x4b, 0xa3, 0x10, 0xc9, 0x50, 0x97, 0x56, 0x85, 0xde, 0x7f, 0x4c,
	0xd8, 0x6f, 0x8a, 0x9f, 0xdc, 0xc9, 0x09, 0x9e, 0x81, 0xeb, 0x66, 0xe4, 0xee, 0x21, 0x38, 0x09,
	0xf7, 0xa3, 0x37, 0x3c, 0x91, 0xb5, 0x41, 0xae, 0xa1, 0x28, 0x20, 0x5d, 0x93, 0x13, 0x0f, 0xfa,
	0x5c, 0x0e, 0x34, 0xb4, 0xea, 0xe3, 0x50, 0x91, 0x21, 0x8d, 0x11, 0xcc, 0x7f, 0x3d, 0x4f, 0x98,
	0xaf, 0xce, 0x86, 0xa4, 0x31, 0xb9, 0x04, 0xf5, 0x7e, 0xc2, 0x79, 0x38, 0x7b, 0x15, 0x09, 0x8c,
	0xa1, 0x4f, 0x4b, 0x92, 0x75, 0x2a, 0xb5, 0xdb, 0x44, 0xa5, 0x5c, 0x68, 0xeb, 0xa4, 0x6a, 0x1e,
	0x96, 0x4d, 0xc9, 0x53, 0xe8, 0xe2, 0x7e, 0x10, 0x0b, 0x3a, 0x88, 0x05, 0x47, 0xdb, 0x34, 0xc8,
	0xd1, 0x24, 0xf3, 0xa2, 0xc5, 0x02, 0xde, 0x47, 0xd0, 0xcd, 0xe5, 0x12, 0x87, 0x4e, 0x66, 0xb3,
	0x09, 0x9d, 0x4f, 0x9f, 0x9d, 0x3b, 0x3b, 0xc4, 0x81, 0xfe, 0xf3, 0x09, 0x9d, 0x9e, 0x4d, 0x4f,
	0x4f, 0x50, 0x62, 0x78, 0x7f, 0x30, 0xc0, 0xa9, 0x97, 0xb8, 0x96, 0x10, 0x63, 0x2d, 0x21, 0xf5,
	0xa4, 0x9a, 0x1b, 0x92, 0x5a, 0x24, 0xcd, 0x6a, 0x4a, 0x5a, 0x95, 0x40, 0xd8, 0x4d, 0x04, 0xe2,
	0x5f, 0xb6, 0xde, 0xde, 0x6c, 0x15, 0x08, 0xae, 0xfb, 0xe2, 0x44, 0xfd, 0x1e, 0x50, 0x33, 0x75,
	0x1e, 0x7b, 0xeb, 0xbc, 0x2e, 0xff, 0x9d, 0xa0, 0x4f, 0x53, 0xd9, 0xe7, 0x5b, 0x7a, 0x92, 0x8a,
	0x86, 0xb7, 0xeb, 0x0d, 0x2f, 0x37, 0x9f, 0x9e, 0xe1, 0xf4, 0x34, 0x5a, 0x85, 0xaa, 0x0d, 0x5b,
	0x74, 0x4d, 0xbe, 0x65, 0x33, 0x8e, 0xa0, 0x97, 0xae, 0x7c, 0x9f, 0xa7, 0x29, 0x65, 0x42, 0x3d,
	0x25, 0x4d, 0x5a, 0x16, 0x49, 0x0b, 0x1e, 0xbe, 0x09, 0x92, 0x28, 0xc4, 0x27, 0x6a, 0x47, 0xfd,
	0x83, 0x29, 0x89, 0xf2, 0x6b, 0xbb, 0xab, 0xf1, 0x5a, 0x5e, 0xe5, 0x23, 0xe8, 0xc5, 0x49, 0xf4,
	0x35, 0xf7, 0x05, 0xfe, 0xa9, 0x00, 0xe5, 0x55, 0x12, 0x49, 0x1e, 0x2b, 0x82, 0x25, 0x4f, 0x05,
	0x5b, 0xc6, 0xfa, 0x69, 0x50, 0x08, 0xc8, 0x47, 0x70, 0x0b, 0x23, 0x9a, 0x29, 0x84, 0x50, 0xa1,
	0xf6, 0x31, 0xd4, 0x75, 0x45, 0x13, 0xf9, 0x1a, 0x6c, 0x4f, 0xbe, 0x86, 0x1b, 0xc8, 0xd7, 0x5f,
	0x2d, 0xd8, 0xab, 0x35, 0x0f, 0x52, 0x84, 0x4c, 0xf4, 0x6e, 0xf6, 0x25, 0x7d, 0x0a, 0x5b, 0x84,
	0x40, 0xcd, 0x99, 0x55, 0x30, 0x9a, 0x27, 0x57, 0x84, 0xe4, 0x11, 0xdc, 0xce, 0x04, 0xe5, 0x1a,
	0x5b, 0x68, 0xdb, 0xa4, 0xda, 0xd8, 0x2a, 0x8f, 0xe0, 0xb6, 0x1a, 0x8d, 0x99, 0x60, 0xd9, 0xdd,
	0xa5, 0x38, 0x69, 0x8b, 0x36, 0xa9, 0xb6, 0x47, 0xaf, 0x0c, 0xe4, 0xdb, 0x55, 0x90, 0x3f, 0x86,
	0xfd, 0x6c, 0x83, 0x95, 0xaa, 0x75, 0x70, 0xf3, 0x8d, 0x3a, 0xf4, 0x51, 0xf3, 0xea, 0x36, 0xbb,
	0xb8, 0xcd, 0x46, 0x1d, 0xf9, 0x18, 0x76, 0x79, 0xf1, 0xd0, 0xec, 0x1d, 0x7f, 0x67, 0xed, 0x21,
	0x27, 0xb5, 0x54, 0x1b, 0x79, 0x7f, 0x33, 0xa0, 0xa5, 0xae, 0x80, 0x4f, 0xc0, 0x16, 0x05, 0xcb,
	0x7a, 0xd0, 0xe8, 0x56, 0x82, 0x52, 0x34, 0xce, 0xfe, 0xb7, 0x21, 0x85, 0x32, 0x8b, 0xff, 0x6d,
	0x48, 0xa3, 0xee, 0x03, 0x2c, 0x82, 0x90, 0x9f, 0xaf, 0x96, 0x2f, 0x34, 0x61, 0x6c, 0xd1, 0x92,
	0xa4, 0x8c, 0xf4, 0xea, 0x32, 0xc9, 0xa6, 0xde, 0x71, 0x19, 0x9b, 0xf7, 0xa0, 0x77, 0x71, 0x42,
	0x67, 0x93, 0xaf, 0x26, 0x94, 0x3e, 0xa3, 0xce, 0x0e, 0xd9, 0x07, 0xe7, 0xf9, 0xc9, 0xd3, 0xe9,
	0x18, 0xb1, 0x59, 0x4b, 0x0d, 0xef, 0x77, 0x06, 0x0c, 0x73, 0x86, 0xf1, 0x1c, 0xb9, 0x1d, 0xbe,
	0x05, 0xf5, 0x44, 0xc3, 0x73, 0x21, 0x20, 0x8f, 0xe1, 0x4e, 0x4e, 0x10, 0x83, 0xdf, 0xf0, 0xcb,
	0xdc, 0x4f, 0x07, 0xb2, 0x41, 0xab, 0x9f, 0x5f, 0x4a, 0xa3, 0xde, 0x57, 0xea, 0xf9, 0xa5, 0x25,
	0x0f, 0x3f, 0x87, 0xbd, 0xda, 0x5b, 0x59, 0x86, 0x70, 0xfe, 0x6c, 0x3e, 0xf9, 0xd5, 0xe4, 0xf4,
	0x97, 0xf3, 0xc9, 0xd8, 0xd9, 0x91, 0xf4, 0xf0, 0x42, 0x5e, 0x38, 0x63, 0xc7, 0x90, 0xe3, 0xb3,
	0x93, 0xe9, 0xd3, 0xc9, 0xd8, 0x31, 0x25, 0x55, 0x9c, 0xfd, 0x62, 0x7a, 0x71, 0x31, 0x19, 0x3b,
	0xd6, 0x67, 0xb7, 0xfe, 0x64, 0x0e, 0x3f, 0xc7, 0x22, 0x64, 0x67, 0xee, 0xc5, 0x2e, 0x9e, 0x98,
	0x4f, 0xfe, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x42, 0x73, 0x0d, 0xa8, 0x24, 0x16, 0x00, 0x00,
}
