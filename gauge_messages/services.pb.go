// Code generated by protoc-gen-go. DO NOT EDIT.
// source: services.proto

package gauge_messages

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("services.proto", fileDescriptor_8e16ccb8c5307b32) }

var fileDescriptor_8e16ccb8c5307b32 = []byte{
	// 688 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xdb, 0x6e, 0xd3, 0x40,
	0x10, 0x95, 0x10, 0x2a, 0x30, 0x2d, 0x69, 0x59, 0xd4, 0x0b, 0xad, 0x50, 0xcb, 0x1d, 0x2a, 0xb0,
	0x50, 0x11, 0x1f, 0x00, 0xbd, 0x44, 0x15, 0xb4, 0x8a, 0x62, 0xa9, 0xa2, 0x95, 0x00, 0x6d, 0xdc,
	0x49, 0xb2, 0xad, 0xe3, 0x35, 0xbb, 0x63, 0xa0, 0x7c, 0x12, 0x2f, 0x3c, 0xf1, 0x7f, 0xc8, 0xf1,
	0x25, 0x89, 0xed, 0x75, 0x6a, 0xd3, 0xb7, 0x68, 0x67, 0xe6, 0x9c, 0x39, 0xbb, 0xb3, 0x7b, 0x62,
	0x68, 0x68, 0x54, 0xdf, 0x85, 0x83, 0xda, 0xf2, 0x95, 0x24, 0xc9, 0x1a, 0x3d, 0x1e, 0xf4, 0xd0,
	0x1a, 0xa0, 0xd6, 0xbc, 0x87, 0x7a, 0xb5, 0x91, 0xfc, 0x8a, 0xe2, 0x5b, 0x7f, 0x17, 0x60, 0xa6,
	0x1d, 0x78, 0x1e, 0x2a, 0x76, 0x0c, 0x73, 0x47, 0xdc, 0x15, 0xa7, 0x9c, 0xd0, 0x26, 0xf4, 0xd9,
	0x23, 0x6b, 0xb2, 0xd6, 0x0a, 0x57, 0x93, 0x8c, 0x36, 0x7e, 0x0b, 0x50, 0xd3, 0xea, 0xe3, 0xf2,
	0x24, 0xed, 0x4b, 0x4f, 0x23, 0x3b, 0x81, 0x95, 0x7d, 0x4f, 0x90, 0xe0, 0xae, 0xf8, 0x85, 0x76,
	0x20, 0x08, 0x77, 0x38, 0x71, 0x9b, 0xa4, 0x42, 0xb6, 0x98, 0x45, 0xd8, 0x1d, 0xf8, 0x74, 0xb1,
	0xfa, 0x2c, 0xb7, 0xfc, 0x13, 0x9d, 0x80, 0x84, 0xf4, 0x6c, 0xe2, 0x14, 0xe8, 0x14, 0xdb, 0x81,
	0x86, 0x4d, 0x5c, 0x51, 0x1a, 0x67, 0xcf, 0xcb, 0x4a, 0x15, 0x09, 0xaf, 0x97, 0x74, 0x7f, 0x69,
	0x92, 0x63, 0x58, 0x1e, 0x13, 0xe0, 0xa3, 0x73, 0x75, 0xfd, 0x9f, 0x03, 0x1b, 0xb6, 0x15, 0xa2,
	0x8e, 0x34, 0xbc, 0xcc, 0xed, 0xeb, 0x78, 0xb8, 0xb6, 0x8e, 0xcf, 0xb0, 0x36, 0xa6, 0xc3, 0x41,
	0x8f, 0x2b, 0x21, 0xaf, 0x4e, 0x8b, 0x86, 0xa5, 0x48, 0x4b, 0x8c, 0x3c, 0xd2, 0xf3, 0x3a, 0xa7,
	0x27, 0x9b, 0x52, 0x5b, 0x53, 0xba, 0x81, 0x84, 0x7e, 0xd9, 0x06, 0x8e, 0x87, 0x6b, 0x93, 0x9d,
	0xc0, 0x6c, 0x14, 0x8a, 0xee, 0xc8, 0xc3, 0xe2, 0xba, 0x61, 0xb0, 0x32, 0xf6, 0x19, 0xdc, 0xdd,
	0x13, 0x9e, 0xd0, 0xfd, 0x49, 0x25, 0x9b, 0xa5, 0x4a, 0x76, 0xbd, 0xd3, 0x3a, 0x3a, 0x14, 0x2c,
	0xc7, 0x5c, 0xb9, 0xa3, 0xb2, 0xa6, 0x1e, 0x55, 0x4d, 0xce, 0x91, 0xbe, 0x89, 0x51, 0xdf, 0x2c,
	0x1d, 0xf5, 0x9a, 0x5c, 0x1d, 0x98, 0x8f, 0xb8, 0x46, 0x3c, 0x4f, 0x8d, 0xb5, 0x35, 0x39, 0x76,
	0xe0, 0xd6, 0x36, 0x77, 0xfa, 0xb8, 0x27, 0x5c, 0x64, 0x1b, 0xd9, 0xaa, 0x34, 0x94, 0xe0, 0x16,
	0x5f, 0x2e, 0xd6, 0x82, 0xd9, 0x26, 0x0e, 0x87, 0xf7, 0x90, 0x0f, 0x90, 0xad, 0x17, 0x9d, 0x76,
	0x18, 0x49, 0x60, 0x36, 0xcc, 0x09, 0x71, 0x5f, 0x5f, 0x61, 0xbe, 0x89, 0xd4, 0x74, 0x65, 0xa7,
	0xc5, 0x89, 0x50, 0x79, 0xda, 0x74, 0xb1, 0xdf, 0x66, 0x97, 0xf7, 0x07, 0xbe, 0x8b, 0x03, 0xf4,
	0x88, 0x87, 0x7a, 0xc3, 0xee, 0xc7, 0x60, 0x52, 0x02, 0x1b, 0xe6, 0xc6, 0x5a, 0xd6, 0xcc, 0xd8,
	0x92, 0x4e, 0x9a, 0x7e, 0x50, 0x92, 0x91, 0x76, 0xbd, 0x10, 0x83, 0xb6, 0xa4, 0x16, 0x21, 0xbd,
	0x66, 0x85, 0xee, 0x92, 0x86, 0x13, 0xf0, 0x27, 0x53, 0xb2, 0x52, 0x82, 0xa5, 0x26, 0x52, 0x5e,
	0xa1, 0x71, 0x77, 0xac, 0xe9, 0xbb, 0xf3, 0x51, 0x68, 0x4a, 0x09, 0x3e, 0xc1, 0xed, 0x34, 0xc3,
	0xa6, 0xa0, 0xc3, 0x5e, 0xe5, 0x1b, 0x0b, 0x3a, 0x93, 0x20, 0xdb, 0xf2, 0x34, 0x3d, 0xd9, 0x95,
	0x6c, 0x7a, 0xc8, 0xb0, 0x23, 0xba, 0x5d, 0x76, 0x00, 0x37, 0xdb, 0xd8, 0xe5, 0x0e, 0x49, 0x95,
	0x1f, 0x90, 0x24, 0x62, 0x1c, 0x90, 0x51, 0x42, 0xdc, 0xe8, 0x3b, 0xb8, 0xfe, 0x41, 0xb8, 0x6e,
	0xfe, 0xf5, 0x0a, 0x57, 0x5b, 0x4a, 0x3a, 0xa8, 0x75, 0xf9, 0xd4, 0x6e, 0xfd, 0xb9, 0x11, 0xb6,
	0xe4, 0x4b, 0x45, 0xa8, 0xd8, 0x09, 0x2c, 0x1f, 0x4a, 0x12, 0xdd, 0x8b, 0xdc, 0xfb, 0x5a, 0xc1,
	0x8b, 0x0d, 0xd7, 0xa3, 0x03, 0x6b, 0x11, 0x76, 0xa1, 0x01, 0x56, 0xf4, 0x49, 0x03, 0xc7, 0x19,
	0xac, 0xc7, 0x1c, 0x26, 0x53, 0xaa, 0xe1, 0x5f, 0x53, 0xf5, 0x14, 0xf9, 0x51, 0x45, 0xdb, 0x32,
	0x70, 0x7c, 0x81, 0x7b, 0x05, 0x1c, 0xd1, 0x2b, 0x57, 0xc9, 0x4e, 0x0c, 0xf8, 0x5d, 0xb8, 0x6f,
	0xd8, 0xaf, 0x98, 0xa3, 0xaa, 0x85, 0x4c, 0xd5, 0x91, 0x77, 0x84, 0x4a, 0xb6, 0x61, 0xc0, 0x3f,
	0x82, 0xc5, 0xcc, 0xdc, 0xc6, 0xd8, 0x97, 0xb5, 0x0a, 0xe3, 0x93, 0x7e, 0x27, 0xee, 0x3b, 0xfc,
	0xab, 0xdb, 0x46, 0x1d, 0xb8, 0x54, 0xf0, 0x96, 0x85, 0xc1, 0x14, 0x38, 0xca, 0x32, 0x21, 0xfe,
	0xff, 0x8d, 0x7d, 0xff, 0x02, 0x96, 0x1c, 0x39, 0xb0, 0xa8, 0x2f, 0x83, 0x5e, 0x9f, 0x7e, 0x48,
	0x75, 0xae, 0xa3, 0xc4, 0xdf, 0xd7, 0x1a, 0xcd, 0x61, 0xc1, 0x41, 0x5c, 0xd0, 0x99, 0x19, 0x7e,
	0x1b, 0xbc, 0xf9, 0x17, 0x00, 0x00, 0xff, 0xff, 0x51, 0x45, 0x6d, 0x2e, 0x4d, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RunnerClient is the client API for Runner service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RunnerClient interface {
	// ValidateStep is a RPC to validate a given step.
	//
	// Accepts a StepValidateRequest message and returns a StepValidateResponse message
	ValidateStep(ctx context.Context, in *StepValidateRequest, opts ...grpc.CallOption) (*StepValidateResponse, error)
	// SuiteDataStoreInit is a RPC to initialize the suite level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSuiteDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecutionStarting is a RPC to tell runner to execute Suite level hooks.
	//
	// Accepts a ExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartExecution(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecDataStoreInit is a RPC to initialize the spec level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSpecDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecExecutionStarting is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartSpecExecution(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioDataStoreInit is a RPC to initialize the scenario level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeScenarioDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioExecutionStarting is a RPC to tell runner to execute scenario level hooks.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartScenarioExecution(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// StepExecutionStarting is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartStepExecution(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecuteStep is a RPC to tell runner to execute a step .
	//
	// Accepts a ExecuteStepRequest message and returns a ExecutionStatusResponse message
	ExecuteStep(ctx context.Context, in *ExecuteStepRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// StepExecutionEnding is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishStepExecution(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioExecutionEnding is a RPC to tell runner to execute Scenario level hooks.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishScenarioExecution(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecExecutionEnding is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishSpecExecution(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecutionEnding is a RPC to tell runner to execute suite level hooks.
	//
	// Accepts a ExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishExecution(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// CacheFile is a RPC to tell runner to load/reload/unload a implementation file.
	//
	// Accepts a CacheFileRequest message and returns a Empty message
	CacheFile(ctx context.Context, in *CacheFileRequest, opts ...grpc.CallOption) (*Empty, error)
	// GetStepName is a RPC to get information about the given step.
	//
	// Accepts a StepNameRequest message and returns a StepNameResponse message.
	GetStepName(ctx context.Context, in *StepNameRequest, opts ...grpc.CallOption) (*StepNameResponse, error)
	// GetGlobPatterns is a RPC to get the file path pattern which needs to be cached.
	//
	// Accepts a Empty message and returns a ImplementationFileGlobPatternResponse message.
	GetGlobPatterns(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileGlobPatternResponse, error)
	// GetStepNames is a RPC to get all the available steps from the runner.
	//
	// Accepts a StepNamesRequest message and returns a StepNamesResponse
	GetStepNames(ctx context.Context, in *StepNamesRequest, opts ...grpc.CallOption) (*StepNamesResponse, error)
	// GetStepPositions is a RPC to get positions of all available steps in a given file.
	//
	// Accepts a StepPositionsRequest message and returns a StepPositionsResponse message
	GetStepPositions(ctx context.Context, in *StepPositionsRequest, opts ...grpc.CallOption) (*StepPositionsResponse, error)
	// GetImplementationFiles is a RPC get all the existing implementation files.
	//
	// Accepts a Empty and returns a ImplementationFileListResponse message.
	GetImplementationFiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileListResponse, error)
	// ImplementStub is a RPC to to ask runner to add a given implementation to given file.
	//
	// Accepts a StubImplementationCodeRequest and returns a FileDiff message.
	ImplementStub(ctx context.Context, in *StubImplementationCodeRequest, opts ...grpc.CallOption) (*FileDiff, error)
	// Refactor is a RPC to refactor a given step in implementation file.
	//
	// Accepts a RefactorRequest message and returns a RefactorResponse message.
	Refactor(ctx context.Context, in *RefactorRequest, opts ...grpc.CallOption) (*RefactorResponse, error)
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error)
}

type runnerClient struct {
	cc *grpc.ClientConn
}

func NewRunnerClient(cc *grpc.ClientConn) RunnerClient {
	return &runnerClient{cc}
}

func (c *runnerClient) ValidateStep(ctx context.Context, in *StepValidateRequest, opts ...grpc.CallOption) (*StepValidateResponse, error) {
	out := new(StepValidateResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/ValidateStep", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) InitializeSuiteDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/InitializeSuiteDataStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) StartExecution(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/StartExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) InitializeSpecDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/InitializeSpecDataStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) StartSpecExecution(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/StartSpecExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) InitializeScenarioDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/InitializeScenarioDataStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) StartScenarioExecution(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/StartScenarioExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) StartStepExecution(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/StartStepExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) ExecuteStep(ctx context.Context, in *ExecuteStepRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/ExecuteStep", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) FinishStepExecution(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/FinishStepExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) FinishScenarioExecution(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/FinishScenarioExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) FinishSpecExecution(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/FinishSpecExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) FinishExecution(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/FinishExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) CacheFile(ctx context.Context, in *CacheFileRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/CacheFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetStepName(ctx context.Context, in *StepNameRequest, opts ...grpc.CallOption) (*StepNameResponse, error) {
	out := new(StepNameResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/GetStepName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetGlobPatterns(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileGlobPatternResponse, error) {
	out := new(ImplementationFileGlobPatternResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/GetGlobPatterns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetStepNames(ctx context.Context, in *StepNamesRequest, opts ...grpc.CallOption) (*StepNamesResponse, error) {
	out := new(StepNamesResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/GetStepNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetStepPositions(ctx context.Context, in *StepPositionsRequest, opts ...grpc.CallOption) (*StepPositionsResponse, error) {
	out := new(StepPositionsResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/GetStepPositions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetImplementationFiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileListResponse, error) {
	out := new(ImplementationFileListResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/GetImplementationFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) ImplementStub(ctx context.Context, in *StubImplementationCodeRequest, opts ...grpc.CallOption) (*FileDiff, error) {
	out := new(FileDiff)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/ImplementStub", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) Refactor(ctx context.Context, in *RefactorRequest, opts ...grpc.CallOption) (*RefactorResponse, error) {
	out := new(RefactorResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/Refactor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/Kill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RunnerServer is the server API for Runner service.
type RunnerServer interface {
	// ValidateStep is a RPC to validate a given step.
	//
	// Accepts a StepValidateRequest message and returns a StepValidateResponse message
	ValidateStep(context.Context, *StepValidateRequest) (*StepValidateResponse, error)
	// SuiteDataStoreInit is a RPC to initialize the suite level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSuiteDataStore(context.Context, *Empty) (*ExecutionStatusResponse, error)
	// ExecutionStarting is a RPC to tell runner to execute Suite level hooks.
	//
	// Accepts a ExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartExecution(context.Context, *ExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// SpecDataStoreInit is a RPC to initialize the spec level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSpecDataStore(context.Context, *Empty) (*ExecutionStatusResponse, error)
	// SpecExecutionStarting is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartSpecExecution(context.Context, *SpecExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// ScenarioDataStoreInit is a RPC to initialize the scenario level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeScenarioDataStore(context.Context, *Empty) (*ExecutionStatusResponse, error)
	// ScenarioExecutionStarting is a RPC to tell runner to execute scenario level hooks.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartScenarioExecution(context.Context, *ScenarioExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// StepExecutionStarting is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartStepExecution(context.Context, *StepExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// ExecuteStep is a RPC to tell runner to execute a step .
	//
	// Accepts a ExecuteStepRequest message and returns a ExecutionStatusResponse message
	ExecuteStep(context.Context, *ExecuteStepRequest) (*ExecutionStatusResponse, error)
	// StepExecutionEnding is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishStepExecution(context.Context, *StepExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// ScenarioExecutionEnding is a RPC to tell runner to execute Scenario level hooks.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishScenarioExecution(context.Context, *ScenarioExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// SpecExecutionEnding is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishSpecExecution(context.Context, *SpecExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// ExecutionEnding is a RPC to tell runner to execute suite level hooks.
	//
	// Accepts a ExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishExecution(context.Context, *ExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// CacheFile is a RPC to tell runner to load/reload/unload a implementation file.
	//
	// Accepts a CacheFileRequest message and returns a Empty message
	CacheFile(context.Context, *CacheFileRequest) (*Empty, error)
	// GetStepName is a RPC to get information about the given step.
	//
	// Accepts a StepNameRequest message and returns a StepNameResponse message.
	GetStepName(context.Context, *StepNameRequest) (*StepNameResponse, error)
	// GetGlobPatterns is a RPC to get the file path pattern which needs to be cached.
	//
	// Accepts a Empty message and returns a ImplementationFileGlobPatternResponse message.
	GetGlobPatterns(context.Context, *Empty) (*ImplementationFileGlobPatternResponse, error)
	// GetStepNames is a RPC to get all the available steps from the runner.
	//
	// Accepts a StepNamesRequest message and returns a StepNamesResponse
	GetStepNames(context.Context, *StepNamesRequest) (*StepNamesResponse, error)
	// GetStepPositions is a RPC to get positions of all available steps in a given file.
	//
	// Accepts a StepPositionsRequest message and returns a StepPositionsResponse message
	GetStepPositions(context.Context, *StepPositionsRequest) (*StepPositionsResponse, error)
	// GetImplementationFiles is a RPC get all the existing implementation files.
	//
	// Accepts a Empty and returns a ImplementationFileListResponse message.
	GetImplementationFiles(context.Context, *Empty) (*ImplementationFileListResponse, error)
	// ImplementStub is a RPC to to ask runner to add a given implementation to given file.
	//
	// Accepts a StubImplementationCodeRequest and returns a FileDiff message.
	ImplementStub(context.Context, *StubImplementationCodeRequest) (*FileDiff, error)
	// Refactor is a RPC to refactor a given step in implementation file.
	//
	// Accepts a RefactorRequest message and returns a RefactorResponse message.
	Refactor(context.Context, *RefactorRequest) (*RefactorResponse, error)
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(context.Context, *KillProcessRequest) (*Empty, error)
}

func RegisterRunnerServer(s *grpc.Server, srv RunnerServer) {
	s.RegisterService(&_Runner_serviceDesc, srv)
}

func _Runner_ValidateStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ValidateStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/ValidateStep",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ValidateStep(ctx, req.(*StepValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_InitializeSuiteDataStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).InitializeSuiteDataStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/InitializeSuiteDataStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).InitializeSuiteDataStore(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_StartExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).StartExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/StartExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).StartExecution(ctx, req.(*ExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_InitializeSpecDataStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).InitializeSpecDataStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/InitializeSpecDataStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).InitializeSpecDataStore(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_StartSpecExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).StartSpecExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/StartSpecExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).StartSpecExecution(ctx, req.(*SpecExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_InitializeScenarioDataStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).InitializeScenarioDataStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/InitializeScenarioDataStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).InitializeScenarioDataStore(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_StartScenarioExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).StartScenarioExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/StartScenarioExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).StartScenarioExecution(ctx, req.(*ScenarioExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_StartStepExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).StartStepExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/StartStepExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).StartStepExecution(ctx, req.(*StepExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_ExecuteStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteStepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ExecuteStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/ExecuteStep",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ExecuteStep(ctx, req.(*ExecuteStepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_FinishStepExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).FinishStepExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/FinishStepExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).FinishStepExecution(ctx, req.(*StepExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_FinishScenarioExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).FinishScenarioExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/FinishScenarioExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).FinishScenarioExecution(ctx, req.(*ScenarioExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_FinishSpecExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).FinishSpecExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/FinishSpecExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).FinishSpecExecution(ctx, req.(*SpecExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_FinishExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).FinishExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/FinishExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).FinishExecution(ctx, req.(*ExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_CacheFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CacheFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).CacheFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/CacheFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).CacheFile(ctx, req.(*CacheFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetStepName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetStepName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/GetStepName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetStepName(ctx, req.(*StepNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetGlobPatterns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetGlobPatterns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/GetGlobPatterns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetGlobPatterns(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetStepNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetStepNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/GetStepNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetStepNames(ctx, req.(*StepNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetStepPositions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepPositionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetStepPositions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/GetStepPositions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetStepPositions(ctx, req.(*StepPositionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetImplementationFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetImplementationFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/GetImplementationFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetImplementationFiles(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_ImplementStub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StubImplementationCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ImplementStub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/ImplementStub",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ImplementStub(ctx, req.(*StubImplementationCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_Refactor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefactorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).Refactor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/Refactor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).Refactor(ctx, req.(*RefactorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/Kill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).Kill(ctx, req.(*KillProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Runner_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Runner",
	HandlerType: (*RunnerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateStep",
			Handler:    _Runner_ValidateStep_Handler,
		},
		{
			MethodName: "InitializeSuiteDataStore",
			Handler:    _Runner_InitializeSuiteDataStore_Handler,
		},
		{
			MethodName: "StartExecution",
			Handler:    _Runner_StartExecution_Handler,
		},
		{
			MethodName: "InitializeSpecDataStore",
			Handler:    _Runner_InitializeSpecDataStore_Handler,
		},
		{
			MethodName: "StartSpecExecution",
			Handler:    _Runner_StartSpecExecution_Handler,
		},
		{
			MethodName: "InitializeScenarioDataStore",
			Handler:    _Runner_InitializeScenarioDataStore_Handler,
		},
		{
			MethodName: "StartScenarioExecution",
			Handler:    _Runner_StartScenarioExecution_Handler,
		},
		{
			MethodName: "StartStepExecution",
			Handler:    _Runner_StartStepExecution_Handler,
		},
		{
			MethodName: "ExecuteStep",
			Handler:    _Runner_ExecuteStep_Handler,
		},
		{
			MethodName: "FinishStepExecution",
			Handler:    _Runner_FinishStepExecution_Handler,
		},
		{
			MethodName: "FinishScenarioExecution",
			Handler:    _Runner_FinishScenarioExecution_Handler,
		},
		{
			MethodName: "FinishSpecExecution",
			Handler:    _Runner_FinishSpecExecution_Handler,
		},
		{
			MethodName: "FinishExecution",
			Handler:    _Runner_FinishExecution_Handler,
		},
		{
			MethodName: "CacheFile",
			Handler:    _Runner_CacheFile_Handler,
		},
		{
			MethodName: "GetStepName",
			Handler:    _Runner_GetStepName_Handler,
		},
		{
			MethodName: "GetGlobPatterns",
			Handler:    _Runner_GetGlobPatterns_Handler,
		},
		{
			MethodName: "GetStepNames",
			Handler:    _Runner_GetStepNames_Handler,
		},
		{
			MethodName: "GetStepPositions",
			Handler:    _Runner_GetStepPositions_Handler,
		},
		{
			MethodName: "GetImplementationFiles",
			Handler:    _Runner_GetImplementationFiles_Handler,
		},
		{
			MethodName: "ImplementStub",
			Handler:    _Runner_ImplementStub_Handler,
		},
		{
			MethodName: "Refactor",
			Handler:    _Runner_Refactor_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _Runner_Kill_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

// ReporterClient is the client API for Reporter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ReporterClient interface {
	// NotifyExecutionStarting is a RPC to tell plugins that the execution has started.
	//
	// Accepts a ExecutionStartingRequest message and returns a Empty message
	NotifyExecutionStarting(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifySpecExecutionStarting is a RPC to tell plugins that the specification execution has started.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a Empty message
	NotifySpecExecutionStarting(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyScenarioExecutionStarting is a RPC to tell plugins that the scenario execution has started.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a Empty message
	NotifyScenarioExecutionStarting(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyStepExecutionStarting is a RPC to tell plugins that the step execution has started.
	//
	// Accepts a StepExecutionStartingRequest message and returns a Empty message
	NotifyStepExecutionStarting(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyStepExecutionEnding is a RPC to tell plugins that the step execution has finished.
	//
	// Accepts a StepExecutionStartingRequest message and returns a Empty message
	NotifyStepExecutionEnding(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyScenarioExecutionEnding is a RPC to tell plugins that the scenario execution has finished.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a Empty message
	NotifyScenarioExecutionEnding(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifySpecExecutionEnding is a RPC to tell plugins that the specification execution has finished.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a Empty message
	NotifySpecExecutionEnding(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifyExecutionEnding is a RPC to tell plugins that the execution has finished.
	//
	// Accepts a ExecutionEndingRequest message and returns a Empty message
	NotifyExecutionEnding(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error)
	// NotifySuiteResult is a RPC to tell about the end result of execution
	//
	// Accepts a SuiteExecutionResult message and returns a Empty message.
	NotifySuiteResult(ctx context.Context, in *SuiteExecutionResult, opts ...grpc.CallOption) (*Empty, error)
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error)
}

type reporterClient struct {
	cc *grpc.ClientConn
}

func NewReporterClient(cc *grpc.ClientConn) ReporterClient {
	return &reporterClient{cc}
}

func (c *reporterClient) NotifyExecutionStarting(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Reporter/NotifyExecutionStarting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifySpecExecutionStarting(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Reporter/NotifySpecExecutionStarting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyScenarioExecutionStarting(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Reporter/NotifyScenarioExecutionStarting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyStepExecutionStarting(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Reporter/NotifyStepExecutionStarting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyStepExecutionEnding(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Reporter/NotifyStepExecutionEnding", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyScenarioExecutionEnding(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Reporter/NotifyScenarioExecutionEnding", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifySpecExecutionEnding(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Reporter/NotifySpecExecutionEnding", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifyExecutionEnding(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Reporter/NotifyExecutionEnding", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) NotifySuiteResult(ctx context.Context, in *SuiteExecutionResult, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Reporter/NotifySuiteResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reporterClient) Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Reporter/Kill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReporterServer is the server API for Reporter service.
type ReporterServer interface {
	// NotifyExecutionStarting is a RPC to tell plugins that the execution has started.
	//
	// Accepts a ExecutionStartingRequest message and returns a Empty message
	NotifyExecutionStarting(context.Context, *ExecutionStartingRequest) (*Empty, error)
	// NotifySpecExecutionStarting is a RPC to tell plugins that the specification execution has started.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a Empty message
	NotifySpecExecutionStarting(context.Context, *SpecExecutionStartingRequest) (*Empty, error)
	// NotifyScenarioExecutionStarting is a RPC to tell plugins that the scenario execution has started.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a Empty message
	NotifyScenarioExecutionStarting(context.Context, *ScenarioExecutionStartingRequest) (*Empty, error)
	// NotifyStepExecutionStarting is a RPC to tell plugins that the step execution has started.
	//
	// Accepts a StepExecutionStartingRequest message and returns a Empty message
	NotifyStepExecutionStarting(context.Context, *StepExecutionStartingRequest) (*Empty, error)
	// NotifyStepExecutionEnding is a RPC to tell plugins that the step execution has finished.
	//
	// Accepts a StepExecutionStartingRequest message and returns a Empty message
	NotifyStepExecutionEnding(context.Context, *StepExecutionEndingRequest) (*Empty, error)
	// NotifyScenarioExecutionEnding is a RPC to tell plugins that the scenario execution has finished.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a Empty message
	NotifyScenarioExecutionEnding(context.Context, *ScenarioExecutionEndingRequest) (*Empty, error)
	// NotifySpecExecutionEnding is a RPC to tell plugins that the specification execution has finished.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a Empty message
	NotifySpecExecutionEnding(context.Context, *SpecExecutionEndingRequest) (*Empty, error)
	// NotifyExecutionEnding is a RPC to tell plugins that the execution has finished.
	//
	// Accepts a ExecutionEndingRequest message and returns a Empty message
	NotifyExecutionEnding(context.Context, *ExecutionEndingRequest) (*Empty, error)
	// NotifySuiteResult is a RPC to tell about the end result of execution
	//
	// Accepts a SuiteExecutionResult message and returns a Empty message.
	NotifySuiteResult(context.Context, *SuiteExecutionResult) (*Empty, error)
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(context.Context, *KillProcessRequest) (*Empty, error)
}

func RegisterReporterServer(s *grpc.Server, srv ReporterServer) {
	s.RegisterService(&_Reporter_serviceDesc, srv)
}

func _Reporter_NotifyExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Reporter/NotifyExecutionStarting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyExecutionStarting(ctx, req.(*ExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifySpecExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifySpecExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Reporter/NotifySpecExecutionStarting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifySpecExecutionStarting(ctx, req.(*SpecExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyScenarioExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyScenarioExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Reporter/NotifyScenarioExecutionStarting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyScenarioExecutionStarting(ctx, req.(*ScenarioExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyStepExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyStepExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Reporter/NotifyStepExecutionStarting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyStepExecutionStarting(ctx, req.(*StepExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyStepExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyStepExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Reporter/NotifyStepExecutionEnding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyStepExecutionEnding(ctx, req.(*StepExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyScenarioExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyScenarioExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Reporter/NotifyScenarioExecutionEnding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyScenarioExecutionEnding(ctx, req.(*ScenarioExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifySpecExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifySpecExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Reporter/NotifySpecExecutionEnding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifySpecExecutionEnding(ctx, req.(*SpecExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifyExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifyExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Reporter/NotifyExecutionEnding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifyExecutionEnding(ctx, req.(*ExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_NotifySuiteResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuiteExecutionResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).NotifySuiteResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Reporter/NotifySuiteResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).NotifySuiteResult(ctx, req.(*SuiteExecutionResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reporter_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReporterServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Reporter/Kill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReporterServer).Kill(ctx, req.(*KillProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Reporter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Reporter",
	HandlerType: (*ReporterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NotifyExecutionStarting",
			Handler:    _Reporter_NotifyExecutionStarting_Handler,
		},
		{
			MethodName: "NotifySpecExecutionStarting",
			Handler:    _Reporter_NotifySpecExecutionStarting_Handler,
		},
		{
			MethodName: "NotifyScenarioExecutionStarting",
			Handler:    _Reporter_NotifyScenarioExecutionStarting_Handler,
		},
		{
			MethodName: "NotifyStepExecutionStarting",
			Handler:    _Reporter_NotifyStepExecutionStarting_Handler,
		},
		{
			MethodName: "NotifyStepExecutionEnding",
			Handler:    _Reporter_NotifyStepExecutionEnding_Handler,
		},
		{
			MethodName: "NotifyScenarioExecutionEnding",
			Handler:    _Reporter_NotifyScenarioExecutionEnding_Handler,
		},
		{
			MethodName: "NotifySpecExecutionEnding",
			Handler:    _Reporter_NotifySpecExecutionEnding_Handler,
		},
		{
			MethodName: "NotifyExecutionEnding",
			Handler:    _Reporter_NotifyExecutionEnding_Handler,
		},
		{
			MethodName: "NotifySuiteResult",
			Handler:    _Reporter_NotifySuiteResult_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _Reporter_Kill_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}
