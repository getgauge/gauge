// Code generated by protoc-gen-go. DO NOT EDIT.
// source: runner.proto

package gauge_messages

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("runner.proto", fileDescriptor_48eceea7e2abc593) }

var fileDescriptor_48eceea7e2abc593 = []byte{
	// 542 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdb, 0x6e, 0xd3, 0x40,
	0x10, 0x95, 0x78, 0xa8, 0x60, 0x12, 0xd2, 0x76, 0x51, 0x0a, 0xe4, 0x85, 0x72, 0xbf, 0x08, 0x2c,
	0x04, 0xe2, 0x07, 0x68, 0x4a, 0xa8, 0xa0, 0x28, 0x8a, 0x11, 0xb7, 0x97, 0x6a, 0xe3, 0x4c, 0x92,
	0x05, 0x7b, 0xd7, 0xec, 0x8e, 0xb9, 0xfc, 0x12, 0x1f, 0xc0, 0xf7, 0xa1, 0x75, 0x6c, 0x93, 0x64,
	0x6d, 0xa7, 0xae, 0xfa, 0x16, 0x79, 0xce, 0x9c, 0xcb, 0xcc, 0xee, 0x2a, 0xd0, 0xd6, 0x89, 0x94,
	0xa8, 0xbd, 0x58, 0x2b, 0x52, 0xac, 0x33, 0xe3, 0xc9, 0x0c, 0xbd, 0x08, 0x8d, 0xe1, 0x33, 0x34,
	0xbd, 0x4e, 0xfe, 0x6b, 0x51, 0x7f, 0xf6, 0x77, 0x07, 0xb6, 0x46, 0x69, 0x03, 0xfb, 0x0c, 0xed,
	0x0f, 0x3c, 0x14, 0x13, 0x4e, 0xe8, 0x13, 0xc6, 0xec, 0xb6, 0xb7, 0xda, 0xeb, 0xd9, 0xaf, 0x39,
	0x62, 0x84, 0xdf, 0x13, 0x34, 0xd4, 0xbb, 0x53, 0x0f, 0x32, 0xb1, 0x92, 0x06, 0xd9, 0x7b, 0x60,
	0x7e, 0x22, 0x08, 0xfb, 0x9c, 0xb8, 0x4f, 0x4a, 0xe3, 0x91, 0x14, 0xc4, 0xba, 0xeb, 0xbd, 0x87,
	0x51, 0x4c, 0xbf, 0x7b, 0xf7, 0x9d, 0xcf, 0xbf, 0x30, 0x48, 0x48, 0x28, 0xe9, 0x13, 0xa7, 0xc4,
	0x14, 0xac, 0x53, 0xd8, 0x5d, 0x2e, 0x69, 0x12, 0x72, 0xc6, 0x1e, 0xd4, 0x75, 0xa7, 0x90, 0xdc,
	0xfa, 0xa9, 0x75, 0x7c, 0xd8, 0xf5, 0x63, 0x0c, 0xce, 0xd7, 0xbc, 0x84, 0xae, 0x25, 0x75, 0x03,
	0x3c, 0x76, 0x26, 0x5a, 0x06, 0x6b, 0x1c, 0xe2, 0x23, 0x74, 0xfd, 0x00, 0x25, 0xd7, 0x42, 0x9d,
	0x6f, 0x90, 0x1f, 0x70, 0x3d, 0x27, 0x76, 0xc3, 0x3c, 0x75, 0xc2, 0x54, 0x41, 0x1b, 0x07, 0xb2,
	0x03, 0x24, 0x8c, 0x4f, 0x33, 0xc0, 0x32, 0x58, 0x63, 0xbd, 0x2f, 0xd0, 0x5a, 0x94, 0x16, 0xb7,
	0xe3, 0x56, 0x79, 0x5f, 0x5a, 0x6c, 0xcc, 0xfd, 0x15, 0xae, 0xac, 0x98, 0x3c, 0x94, 0x13, 0x9b,
	0xe4, 0x51, 0x6d, 0x92, 0x05, 0xa8, 0xb1, 0x96, 0x86, 0xab, 0xce, 0x12, 0x32, 0x3d, 0x6f, 0xe3,
	0xb6, 0xce, 0xa8, 0x69, 0xf3, 0x2d, 0x9f, 0xe2, 0xca, 0x7c, 0x2e, 0xa8, 0xb1, 0xd6, 0x18, 0xb6,
	0xd7, 0x75, 0xee, 0x55, 0xf6, 0x9e, 0x51, 0xc3, 0x87, 0xf6, 0x00, 0xc9, 0x6e, 0xe3, 0x1d, 0x8f,
	0xd0, 0xb0, 0xfd, 0xb2, 0x45, 0xa5, 0xa5, 0x9c, 0xfa, 0x66, 0x0d, 0x22, 0x23, 0xed, 0xc3, 0xa5,
	0x03, 0x1e, 0xcc, 0xf1, 0x95, 0x08, 0xd1, 0x65, 0x2c, 0x4a, 0x39, 0x63, 0xf9, 0xbd, 0x65, 0x27,
	0xb0, 0x93, 0x59, 0x1b, 0x2a, 0x23, 0xac, 0x77, 0xc3, 0x4a, 0x1f, 0xe9, 0xa2, 0x9c, 0x13, 0xde,
	0xdd, 0x80, 0xca, 0x6c, 0x9e, 0xc0, 0xde, 0x00, 0xe9, 0x28, 0x8a, 0x43, 0x8c, 0x50, 0x12, 0xb7,
	0x55, 0xeb, 0xcb, 0x54, 0xbd, 0x24, 0xce, 0xa9, 0x72, 0x7b, 0xdf, 0x0a, 0x43, 0x85, 0xc0, 0x27,
	0xb8, 0x5c, 0x20, 0x7c, 0x4a, 0xc6, 0xec, 0x89, 0x6b, 0x2c, 0x19, 0xaf, 0x92, 0x1c, 0xa8, 0x49,
	0x31, 0x98, 0x6b, 0xeb, 0x70, 0xab, 0xd0, 0x17, 0xd3, 0x29, 0x1b, 0x42, 0x6b, 0x69, 0x6d, 0xec,
	0x46, 0xd5, 0x4e, 0x72, 0xa6, 0xfd, 0x6a, 0x40, 0x31, 0x8c, 0xed, 0x01, 0xd2, 0x20, 0x54, 0xe3,
	0x21, 0x27, 0x42, 0x2d, 0x2b, 0xa7, 0xf0, 0x62, 0xf3, 0x14, 0x96, 0x68, 0x0a, 0x81, 0x63, 0xb8,
	0x38, 0xc2, 0x29, 0x0f, 0x48, 0x69, 0xd7, 0x6f, 0x5e, 0xa9, 0xf4, 0xfb, 0x1f, 0x90, 0xd1, 0xbd,
	0x86, 0xd6, 0x1b, 0x11, 0x86, 0x43, 0xad, 0x02, 0x34, 0xc6, 0x7d, 0xc4, 0x96, 0x8a, 0xf5, 0xe7,
	0xec, 0xe5, 0x43, 0xd8, 0x0b, 0x54, 0xe4, 0xd1, 0x5c, 0x25, 0xb3, 0x39, 0xfd, 0x54, 0xfa, 0x9b,
	0x59, 0x00, 0xff, 0x5c, 0xe8, 0x0c, 0xd2, 0x86, 0xe3, 0xac, 0x61, 0xbc, 0x95, 0xfe, 0xd5, 0x78,
	0xfe, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x78, 0x3c, 0xc1, 0x9a, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RunnerClient is the client API for Runner service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RunnerClient interface {
	// ValidateStep is a RPC to validate a given step.
	//
	// Accepts a StepValidateRequest message and returns a StepValidateResponse message
	ValidateStep(ctx context.Context, in *StepValidateRequest, opts ...grpc.CallOption) (*StepValidateResponse, error)
	// SuiteDataStoreInit is a RPC to initialize the suite level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	SuiteDataStoreInit(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecutionStarting is a RPC to tell runner to execute Suite level hooks.
	//
	// Accepts a ExecutionStartingRequest message and returns a ExecutionStatusResponse message
	ExecutionStarting(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecDataStoreInit is a RPC to initialize the spec level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	SpecDataStoreInit(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecExecutionStarting is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a ExecutionStatusResponse message
	SpecExecutionStarting(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioDataStoreInit is a RPC to initialize the scenario level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	ScenarioDataStoreInit(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioExecutionStarting is a RPC to tell runner to execute scenario level hooks.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a ExecutionStatusResponse message
	ScenarioExecutionStarting(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// StepExecutionStarting is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StepExecutionStarting(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecuteStep is a RPC to tell runner to execute a step .
	//
	// Accepts a ExecuteStepRequest message and returns a ExecutionStatusResponse message
	ExecuteStep(ctx context.Context, in *ExecuteStepRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// StepExecutionEnding is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionEndingRequest message and returns a ExecutionStatusResponse message
	StepExecutionEnding(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioExecutionEnding is a RPC to tell runner to execute Scenario level hooks.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a ExecutionStatusResponse message
	ScenarioExecutionEnding(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecExecutionEnding is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionEndingRequest message and returns a ExecutionStatusResponse message
	SpecExecutionEnding(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecutionEnding is a RPC to tell runner to execute suite level hooks.
	//
	// Accepts a ExecutionEndingRequest message and returns a ExecutionStatusResponse message
	ExecutionEnding(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// GetStepNames is a RPC to get all the available steps from the runner.
	//
	// Accepts a StepNamesRequest message and returns a StepNamesResponse
	GetStepNames(ctx context.Context, in *StepNamesRequest, opts ...grpc.CallOption) (*StepNamesResponse, error)
	// CacheFile is a RPC to tell runner to load/reload/unload a implementation file.
	//
	// Accepts a CacheFileRequest message and returns a Empty message
	CacheFile(ctx context.Context, in *CacheFileRequest, opts ...grpc.CallOption) (*Empty, error)
	// GetStepPositions is a RPC to get all availabe steps in file.
	//
	// Accepts a StepPositionsRequest message and returns a StepPositionsResponse message
	GetStepPositions(ctx context.Context, in *StepPositionsRequest, opts ...grpc.CallOption) (*StepPositionsResponse, error)
	// GetImplementationFiles is a RPC get all the existing implementaiton files.
	//
	// Accepts a Empty and returns a ImplementationFileListResponse message.
	GetImplementationFiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileListResponse, error)
	// ValidateStep is a RPC to to ask ruuner to add a given implementation to given file.
	//
	// Accepts a StubImplementationCodeRequest and returns a FileDiff message.
	ImplementStub(ctx context.Context, in *StubImplementationCodeRequest, opts ...grpc.CallOption) (*FileDiff, error)
	// GetStepName is a RPC to get information about the given step.
	//
	// Accepts a StepNameRequest message and returns a StepNameResponse message.
	GetStepName(ctx context.Context, in *StepNameRequest, opts ...grpc.CallOption) (*StepNameResponse, error)
	// GetGlobPatterns is a RPC to get the file path pattern which needs to be cached.
	//
	// Accepts a Empty message and returns a ImplementationFileGlobPatternResponse message.
	GetGlobPatterns(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileGlobPatternResponse, error)
	// Refactor is a RPC to refactor a given step in implementation file.
	//
	// Accepts a RefactorRequest message and returns a RefactorResponse message.
	Refactor(ctx context.Context, in *RefactorRequest, opts ...grpc.CallOption) (*RefactorResponse, error)
	// KillProcess is a RPC tell runnner to stop grpc server and kill the runner process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	KillProcess(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error)
}

type runnerClient struct {
	cc *grpc.ClientConn
}

func NewRunnerClient(cc *grpc.ClientConn) RunnerClient {
	return &runnerClient{cc}
}

func (c *runnerClient) ValidateStep(ctx context.Context, in *StepValidateRequest, opts ...grpc.CallOption) (*StepValidateResponse, error) {
	out := new(StepValidateResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/ValidateStep", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) SuiteDataStoreInit(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/SuiteDataStoreInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) ExecutionStarting(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/ExecutionStarting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) SpecDataStoreInit(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/SpecDataStoreInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) SpecExecutionStarting(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/SpecExecutionStarting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) ScenarioDataStoreInit(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/ScenarioDataStoreInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) ScenarioExecutionStarting(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/ScenarioExecutionStarting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) StepExecutionStarting(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/StepExecutionStarting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) ExecuteStep(ctx context.Context, in *ExecuteStepRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/ExecuteStep", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) StepExecutionEnding(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/StepExecutionEnding", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) ScenarioExecutionEnding(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/ScenarioExecutionEnding", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) SpecExecutionEnding(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/SpecExecutionEnding", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) ExecutionEnding(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/ExecutionEnding", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetStepNames(ctx context.Context, in *StepNamesRequest, opts ...grpc.CallOption) (*StepNamesResponse, error) {
	out := new(StepNamesResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/GetStepNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) CacheFile(ctx context.Context, in *CacheFileRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/CacheFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetStepPositions(ctx context.Context, in *StepPositionsRequest, opts ...grpc.CallOption) (*StepPositionsResponse, error) {
	out := new(StepPositionsResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/GetStepPositions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetImplementationFiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileListResponse, error) {
	out := new(ImplementationFileListResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/GetImplementationFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) ImplementStub(ctx context.Context, in *StubImplementationCodeRequest, opts ...grpc.CallOption) (*FileDiff, error) {
	out := new(FileDiff)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/ImplementStub", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetStepName(ctx context.Context, in *StepNameRequest, opts ...grpc.CallOption) (*StepNameResponse, error) {
	out := new(StepNameResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/GetStepName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetGlobPatterns(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileGlobPatternResponse, error) {
	out := new(ImplementationFileGlobPatternResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/GetGlobPatterns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) Refactor(ctx context.Context, in *RefactorRequest, opts ...grpc.CallOption) (*RefactorResponse, error) {
	out := new(RefactorResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/Refactor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) KillProcess(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Runner/KillProcess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RunnerServer is the server API for Runner service.
type RunnerServer interface {
	// ValidateStep is a RPC to validate a given step.
	//
	// Accepts a StepValidateRequest message and returns a StepValidateResponse message
	ValidateStep(context.Context, *StepValidateRequest) (*StepValidateResponse, error)
	// SuiteDataStoreInit is a RPC to initialize the suite level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	SuiteDataStoreInit(context.Context, *Empty) (*ExecutionStatusResponse, error)
	// ExecutionStarting is a RPC to tell runner to execute Suite level hooks.
	//
	// Accepts a ExecutionStartingRequest message and returns a ExecutionStatusResponse message
	ExecutionStarting(context.Context, *ExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// SpecDataStoreInit is a RPC to initialize the spec level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	SpecDataStoreInit(context.Context, *Empty) (*ExecutionStatusResponse, error)
	// SpecExecutionStarting is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a ExecutionStatusResponse message
	SpecExecutionStarting(context.Context, *SpecExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// ScenarioDataStoreInit is a RPC to initialize the scenario level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	ScenarioDataStoreInit(context.Context, *Empty) (*ExecutionStatusResponse, error)
	// ScenarioExecutionStarting is a RPC to tell runner to execute scenario level hooks.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a ExecutionStatusResponse message
	ScenarioExecutionStarting(context.Context, *ScenarioExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// StepExecutionStarting is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StepExecutionStarting(context.Context, *StepExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// ExecuteStep is a RPC to tell runner to execute a step .
	//
	// Accepts a ExecuteStepRequest message and returns a ExecutionStatusResponse message
	ExecuteStep(context.Context, *ExecuteStepRequest) (*ExecutionStatusResponse, error)
	// StepExecutionEnding is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionEndingRequest message and returns a ExecutionStatusResponse message
	StepExecutionEnding(context.Context, *StepExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// ScenarioExecutionEnding is a RPC to tell runner to execute Scenario level hooks.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a ExecutionStatusResponse message
	ScenarioExecutionEnding(context.Context, *ScenarioExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// SpecExecutionEnding is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionEndingRequest message and returns a ExecutionStatusResponse message
	SpecExecutionEnding(context.Context, *SpecExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// ExecutionEnding is a RPC to tell runner to execute suite level hooks.
	//
	// Accepts a ExecutionEndingRequest message and returns a ExecutionStatusResponse message
	ExecutionEnding(context.Context, *ExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// GetStepNames is a RPC to get all the available steps from the runner.
	//
	// Accepts a StepNamesRequest message and returns a StepNamesResponse
	GetStepNames(context.Context, *StepNamesRequest) (*StepNamesResponse, error)
	// CacheFile is a RPC to tell runner to load/reload/unload a implementation file.
	//
	// Accepts a CacheFileRequest message and returns a Empty message
	CacheFile(context.Context, *CacheFileRequest) (*Empty, error)
	// GetStepPositions is a RPC to get all availabe steps in file.
	//
	// Accepts a StepPositionsRequest message and returns a StepPositionsResponse message
	GetStepPositions(context.Context, *StepPositionsRequest) (*StepPositionsResponse, error)
	// GetImplementationFiles is a RPC get all the existing implementaiton files.
	//
	// Accepts a Empty and returns a ImplementationFileListResponse message.
	GetImplementationFiles(context.Context, *Empty) (*ImplementationFileListResponse, error)
	// ValidateStep is a RPC to to ask ruuner to add a given implementation to given file.
	//
	// Accepts a StubImplementationCodeRequest and returns a FileDiff message.
	ImplementStub(context.Context, *StubImplementationCodeRequest) (*FileDiff, error)
	// GetStepName is a RPC to get information about the given step.
	//
	// Accepts a StepNameRequest message and returns a StepNameResponse message.
	GetStepName(context.Context, *StepNameRequest) (*StepNameResponse, error)
	// GetGlobPatterns is a RPC to get the file path pattern which needs to be cached.
	//
	// Accepts a Empty message and returns a ImplementationFileGlobPatternResponse message.
	GetGlobPatterns(context.Context, *Empty) (*ImplementationFileGlobPatternResponse, error)
	// Refactor is a RPC to refactor a given step in implementation file.
	//
	// Accepts a RefactorRequest message and returns a RefactorResponse message.
	Refactor(context.Context, *RefactorRequest) (*RefactorResponse, error)
	// KillProcess is a RPC tell runnner to stop grpc server and kill the runner process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	KillProcess(context.Context, *KillProcessRequest) (*Empty, error)
}

func RegisterRunnerServer(s *grpc.Server, srv RunnerServer) {
	s.RegisterService(&_Runner_serviceDesc, srv)
}

func _Runner_ValidateStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ValidateStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/ValidateStep",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ValidateStep(ctx, req.(*StepValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_SuiteDataStoreInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).SuiteDataStoreInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/SuiteDataStoreInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).SuiteDataStoreInit(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_ExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/ExecutionStarting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ExecutionStarting(ctx, req.(*ExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_SpecDataStoreInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).SpecDataStoreInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/SpecDataStoreInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).SpecDataStoreInit(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_SpecExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).SpecExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/SpecExecutionStarting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).SpecExecutionStarting(ctx, req.(*SpecExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_ScenarioDataStoreInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ScenarioDataStoreInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/ScenarioDataStoreInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ScenarioDataStoreInit(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_ScenarioExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ScenarioExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/ScenarioExecutionStarting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ScenarioExecutionStarting(ctx, req.(*ScenarioExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_StepExecutionStarting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).StepExecutionStarting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/StepExecutionStarting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).StepExecutionStarting(ctx, req.(*StepExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_ExecuteStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteStepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ExecuteStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/ExecuteStep",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ExecuteStep(ctx, req.(*ExecuteStepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_StepExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).StepExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/StepExecutionEnding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).StepExecutionEnding(ctx, req.(*StepExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_ScenarioExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ScenarioExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/ScenarioExecutionEnding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ScenarioExecutionEnding(ctx, req.(*ScenarioExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_SpecExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).SpecExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/SpecExecutionEnding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).SpecExecutionEnding(ctx, req.(*SpecExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_ExecutionEnding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ExecutionEnding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/ExecutionEnding",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ExecutionEnding(ctx, req.(*ExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetStepNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetStepNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/GetStepNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetStepNames(ctx, req.(*StepNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_CacheFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CacheFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).CacheFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/CacheFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).CacheFile(ctx, req.(*CacheFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetStepPositions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepPositionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetStepPositions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/GetStepPositions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetStepPositions(ctx, req.(*StepPositionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetImplementationFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetImplementationFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/GetImplementationFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetImplementationFiles(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_ImplementStub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StubImplementationCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).ImplementStub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/ImplementStub",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).ImplementStub(ctx, req.(*StubImplementationCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetStepName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetStepName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/GetStepName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetStepName(ctx, req.(*StepNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetGlobPatterns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetGlobPatterns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/GetGlobPatterns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetGlobPatterns(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_Refactor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefactorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).Refactor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/Refactor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).Refactor(ctx, req.(*RefactorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_KillProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).KillProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Runner/KillProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).KillProcess(ctx, req.(*KillProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Runner_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Runner",
	HandlerType: (*RunnerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateStep",
			Handler:    _Runner_ValidateStep_Handler,
		},
		{
			MethodName: "SuiteDataStoreInit",
			Handler:    _Runner_SuiteDataStoreInit_Handler,
		},
		{
			MethodName: "ExecutionStarting",
			Handler:    _Runner_ExecutionStarting_Handler,
		},
		{
			MethodName: "SpecDataStoreInit",
			Handler:    _Runner_SpecDataStoreInit_Handler,
		},
		{
			MethodName: "SpecExecutionStarting",
			Handler:    _Runner_SpecExecutionStarting_Handler,
		},
		{
			MethodName: "ScenarioDataStoreInit",
			Handler:    _Runner_ScenarioDataStoreInit_Handler,
		},
		{
			MethodName: "ScenarioExecutionStarting",
			Handler:    _Runner_ScenarioExecutionStarting_Handler,
		},
		{
			MethodName: "StepExecutionStarting",
			Handler:    _Runner_StepExecutionStarting_Handler,
		},
		{
			MethodName: "ExecuteStep",
			Handler:    _Runner_ExecuteStep_Handler,
		},
		{
			MethodName: "StepExecutionEnding",
			Handler:    _Runner_StepExecutionEnding_Handler,
		},
		{
			MethodName: "ScenarioExecutionEnding",
			Handler:    _Runner_ScenarioExecutionEnding_Handler,
		},
		{
			MethodName: "SpecExecutionEnding",
			Handler:    _Runner_SpecExecutionEnding_Handler,
		},
		{
			MethodName: "ExecutionEnding",
			Handler:    _Runner_ExecutionEnding_Handler,
		},
		{
			MethodName: "GetStepNames",
			Handler:    _Runner_GetStepNames_Handler,
		},
		{
			MethodName: "CacheFile",
			Handler:    _Runner_CacheFile_Handler,
		},
		{
			MethodName: "GetStepPositions",
			Handler:    _Runner_GetStepPositions_Handler,
		},
		{
			MethodName: "GetImplementationFiles",
			Handler:    _Runner_GetImplementationFiles_Handler,
		},
		{
			MethodName: "ImplementStub",
			Handler:    _Runner_ImplementStub_Handler,
		},
		{
			MethodName: "GetStepName",
			Handler:    _Runner_GetStepName_Handler,
		},
		{
			MethodName: "GetGlobPatterns",
			Handler:    _Runner_GetGlobPatterns_Handler,
		},
		{
			MethodName: "Refactor",
			Handler:    _Runner_Refactor_Handler,
		},
		{
			MethodName: "KillProcess",
			Handler:    _Runner_KillProcess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "runner.proto",
}
